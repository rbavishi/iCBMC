{
{ "isalnum",
  "#line 1 \"<builtin-library>-isalnum\"\n"
  "\n"
  "inline int isalnum(int c)\n"
  "{ return (c>='a' && c<='z') || (c>='A' && c<='Z') || (c>='0' && c<='9'); }\n"
  "\n"
},
{ "isalpha",
  "#line 1 \"<builtin-library>-isalpha\"\n"
  "\n"
  "inline int isalpha(int c)\n"
  "{ return (c>='a' && c<='z') || (c>='A' && c<='Z'); }\n"
  "\n"
},
{ "isblank",
  "#line 1 \"<builtin-library>-isblank\"\n"
  "\n"
  "inline int isblank(int c)\n"
  "{ return c==' ' || c=='\\t'; }\n"
  "\n"
},
{ "iscntrl",
  "#line 1 \"<builtin-library>-iscntrl\"\n"
  "\n"
  "inline int iscntrl(int c)\n"
  "{ return (c>=0 && c<='\\037') || c=='\\177'; }\n"
  "\n"
},
{ "isdigit",
  "#line 1 \"<builtin-library>-isdigit\"\n"
  "\n"
  "inline int isdigit(int c)\n"
  "{ return c>='0' && c<='9'; }\n"
  "\n"
},
{ "isgraph",
  "#line 1 \"<builtin-library>-isgraph\"\n"
  "\n"
  "inline int isgraph(int c)\n"
  "{ return c>='!' && c<='~'; }\n"
  "\n"
},
{ "islower",
  "#line 1 \"<builtin-library>-islower\"\n"
  "\n"
  "inline int islower(int c)\n"
  "{ return c>='a' && c<='z'; }\n"
  "\n"
},
{ "isprint",
  "#line 1 \"<builtin-library>-isprint\"\n"
  "\n"
  "inline int isprint(int c)\n"
  "{ return c>=' ' && c<='~'; }\n"
  "\n"
},
{ "ispunct",
  "#line 1 \"<builtin-library>-ispunct\"\n"
  "\n"
  "inline int ispunct(int c)\n"
  "{ return c=='!' ||\n"
  "         c=='\"' ||\n"
  "         c=='#' ||\n"
  "         c=='$' ||\n"
  "         c=='%' ||\n"
  "         c=='&' ||\n"
  "         c=='\\'' ||\n"
  "         c=='(' ||\n"
  "         c==')' ||\n"
  "         c=='*' ||\n"
  "         c=='+' ||\n"
  "         c==',' ||\n"
  "         c=='-' ||\n"
  "         c=='.' ||\n"
  "         c=='/' ||\n"
  "         c==':' ||\n"
  "         c==';' ||\n"
  "         c=='<' ||\n"
  "         c=='=' ||\n"
  "         c=='>' ||\n"
  "         c=='?' ||\n"
  "         c=='@' ||\n"
  "         c=='[' ||\n"
  "         c=='\\\\' ||\n"
  "         c==']' ||\n"
  "         c=='^' ||\n"
  "         c=='_' ||\n"
  "         c=='`' ||\n"
  "         c=='{' ||\n"
  "         c=='|' ||\n"
  "         c=='}' ||\n"
  "         c=='~'; }\n"
  "\n"
},
{ "isspace",
  "#line 1 \"<builtin-library>-isspace\"\n"
  "\n"
  "inline int isspace(int c)\n"
  "{ return c=='\\t' ||\n"
  "         c=='\\n' ||\n"
  "         c=='\\v' ||\n"
  "         c=='\\f' ||\n"
  "         c=='\\r' ||\n"
  "         c==' '; }\n"
  "\n"
},
{ "isupper",
  "#line 1 \"<builtin-library>-isupper\"\n"
  "\n"
  "inline int isupper(int c)\n"
  "{ return c>='A' && c<='Z'; }\n"
  "\n"
},
{ "isxdigit",
  "#line 1 \"<builtin-library>-isxdigit\"\n"
  "\n"
  "inline int isxdigit(int c)\n"
  "{ return (c>='A' && c<='F') || (c>='a' && c<='f') || (c>='0' && c<='9'); }\n"
  "\n"
},
{ "tolower",
  "#line 1 \"<builtin-library>-tolower\"\n"
  "\n"
  "inline int tolower(int c)\n"
  "{ return (c>='A' && c<='Z')?c+('a'-'A'):c; }\n"
  "\n"
},
{ "toupper",
  "#line 1 \"<builtin-library>-toupper\"\n"
  "\n"
  "inline int toupper(int c)\n"
  "{ return (c>='a' && c<='z')?c-('a'-'A'):c; }\n"
  "\n"
},
{ "err",
  "#line 1 \"<builtin-library>-err\"\n"
  "\n"
  "#ifndef __CPROVER_ERR_H_INCLUDED\n"
  "#include <err.h>\n"
  "#define __CPROVER_ERR_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void err(int eval, const char *fmt, ...)\n"
  "{\n"
  "  (void)eval;\n"
  "  (void)*fmt;\n"
  "  abort();\n"
  "}\n"
  "\n"
},
{ "err",
  "#line 1 \"<builtin-library>-err\"\n"
  "\n"
  "#ifndef __CPROVER_ERR_H_INCLUDED\n"
  "#include <err.h>\n"
  "#define __CPROVER_ERR_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void errx(int eval, const char *fmt, ...)\n"
  "{\n"
  "  (void)eval;\n"
  "  (void)*fmt;\n"
  "  abort();\n"
  "}\n"
  "\n"
},
{ "warn",
  "#line 1 \"<builtin-library>-warn\"\n"
  "\n"
  "#ifndef __CPROVER_ERR_H_INCLUDED\n"
  "#include <err.h>\n"
  "#define __CPROVER_ERR_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void warn(const char *fmt, ...)\n"
  "{\n"
  "  (void)*fmt;\n"
  "}\n"
  "\n"
},
{ "warnx",
  "#line 1 \"<builtin-library>-warnx\"\n"
  "\n"
  "#ifndef __CPROVER_ERR_H_INCLUDED\n"
  "#include <err.h>\n"
  "#define __CPROVER_ERR_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void warnx(const char *fmt, ...)\n"
  "{\n"
  "  (void)*fmt;\n"
  "}\n"
},
{ "__error",
  "#line 1 \"<builtin-library>-__error\"\n"
  "\n"
  "// This is used on MacOS to return the address of a\n"
  "// variable used for the errno macro.\n"
  "\n"
  "__CPROVER_thread_local int __CPROVER_errno;\n"
  "\n"
  "inline int * __error(void)\n"
  "{\n"
  "  return &__CPROVER_errno;\n"
  "}\n"
  "\n"
},
{ "__errno_location",
  "#line 1 \"<builtin-library>-__errno_location\"\n"
  "\n"
  "// This is used on Linux to return the address of a\n"
  "// variable used for the errno macro.\n"
  "\n"
  "__CPROVER_thread_local int __CPROVER_errno;\n"
  "\n"
  "inline int *__errno_location(void)\n"
  "{\n"
  "  return &__CPROVER_errno;\n"
  "}\n"
  "\n"
},
{ "_errno",
  "#line 1 \"<builtin-library>-_errno\"\n"
  "\n"
  "// This is used on Windows to return the address of a\n"
  "// variable used for the errno macro.\n"
  "\n"
  "__CPROVER_thread_local int __CPROVER_errno;\n"
  "\n"
  "inline int *_errno(void)\n"
  "{\n"
  "  return &__CPROVER_errno;\n"
  "}\n"
  "\n"
},
{ "__errno",
  "#line 1 \"<builtin-library>-__errno\"\n"
  "\n"
  "// This has been spotted in CYGWIN\n"
  "\n"
  "__CPROVER_thread_local int __CPROVER_errno;\n"
  "\n"
  "extern int *__errno(void)\n"
  "{\n"
  "  return &__CPROVER_errno;\n"
  "}\n"
  "\n"
},
{ "fcntl",
  "#line 1 \"<builtin-library>-fcntl\"\n"
  "\n"
  "#ifndef __CPROVER_FCNTL_H_INCLUDED\n"
  "#include <fcntl.h>\n"
  "#define __CPROVER_FCNTL_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int fcntl(int fd, int cmd, ...)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  (void)fd;\n"
  "  (void)cmd;\n"
  "  return return_value;\n"
  "}\n"
},
{ "fegetround",
  "#line 1 \"<builtin-library>-fegetround\"\n"
  "\n"
  "#include <fenv.h>\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "inline int fegetround(void)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  // CPROVER uses the x86 numbering of the rounding modes\n"
  "  return\n"
  "         #ifdef FE_DOWNWARD\n"
  "         __CPROVER_rounding_mode==1?FE_DOWNWARD:\n"
  "         #endif\n"
  "         __CPROVER_rounding_mode==0?FE_TONEAREST:\n"
  "         __CPROVER_rounding_mode==3?FE_TOWARDZERO:\n"
  "         #ifdef FE_UPWARD\n"
  "         __CPROVER_rounding_mode==2?FE_UPWARD:\n"
  "         #endif\n"
  "         -1;\n"
  "}\n"
  "\n"
},
{ "fesetround",
  "#line 1 \"<builtin-library>-fesetround\"\n"
  "\n"
  "#include <fenv.h>\n"
  "\n"
  "inline int fesetround(int rounding_mode)\n"
  "{\n"
  "__CPROVER_HIDE:;\n"
  "  // CPROVER uses the x86 numbering of the rounding modes\n"
  "  __CPROVER_rounding_mode=\n"
  "    #ifdef FE_DOWNWARD\n"
  "    rounding_mode==FE_DOWNWARD?1:\n"
  "    #endif\n"
  "    rounding_mode==FE_TONEAREST?0:\n"
  "    rounding_mode==FE_TOWARDZERO?3:\n"
  "    #ifdef FE_UPWARD\n"
  "    rounding_mode==FE_UPWARD?2:\n"
  "    #endif\n"
  "    0;\n"
  "  return 0; // we never fail\n"
  "}\n"
},
{ "_controlfp",
  "#line 1 \"<builtin-library>-_controlfp\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <float.h>\n"
  "\n"
  "__CPROVER_thread_local unsigned __CPROVER_fpu_control_word;\n"
  "\n"
  "unsigned int _controlfp( \n"
  "  unsigned int new_value,\n"
  "  unsigned int mask)\n"
  "{\n"
  "  __CPROVER_fpu_control_word=\n"
  "    (__CPROVER_fpu_control_word&~mask)|new_value;\n"
  "\n"
  "  if((mask&_MCW_RC)!=0)\n"
  "    __CPROVER_rounding_mode=(new_value&_MCW_RC)>>8;\n"
  "  \n"
  "  return __CPROVER_fpu_control_word;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_status87",
  "#line 1 \"<builtin-library>-_status87\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "\n"
  "__CPROVER_thread_local unsigned __CPROVER_fpu_control_word;\n"
  "\n"
  "inline unsigned int _status87(void)\n"
  "{\n"
  "  return __CPROVER_fpu_control_word;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_statusfp",
  "#line 1 \"<builtin-library>-_statusfp\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "\n"
  "__CPROVER_thread_local unsigned __CPROVER_fpu_control_word;\n"
  "\n"
  "inline unsigned int _statusfp(void)\n"
  "{\n"
  "  return __CPROVER_fpu_control_word;\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_statusfp2",
  "#line 1 \"<builtin-library>-_statusfp2\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "\n"
  "__CPROVER_thread_local unsigned __CPROVER_fpu_control_word;\n"
  "\n"
  "inline void _statusfp2(unsigned int *px86, unsigned int *pSSE2)\n"
  "{\n"
  "  unsigned SSE2_status;\n"
  "  *px86=__CPROVER_fpu_control_word;\n"
  "  *pSSE2=SSE2_status; // nondet\n"
  "}\n"
  "\n"
  "#endif\n"
  "\n"
},
{ "_isnan",
  "#line 1 \"<builtin-library>-_isnan\"\n"
  "\n"
  "inline int _isnan(double x)\n"
  "{\n"
  "  return __CPROVER_isnand(x);\n"
  "}\n"
},
{ "__builtin_ia32_sfence",
  "#line 1 \"<builtin-library>-__builtin_ia32_sfence\"\n"
  "\n"
  "inline void __builtin_ia32_sfence(void)\n"
  "{\n"
  "  __asm(\"sfence\");\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_lfence",
  "#line 1 \"<builtin-library>-__builtin_ia32_lfence\"\n"
  "\n"
  "inline void __builtin_ia32_lfence(void)\n"
  "{\n"
  "  __asm(\"lfence\");\n"
  "}\n"
  "\n"
},
{ "__builtin_ia32_mfence",
  "#line 1 \"<builtin-library>-__builtin_ia32_mfence\"\n"
  "\n"
  "inline void __builtin_ia32_mfence(void)\n"
  "{\n"
  "  __asm(\"mfence\");\n"
  "}\n"
  "\n"
},
{ "__sync_synchronize",
  "#line 1 \"<builtin-library>-__sync_synchronize\"\n"
  "\n"
  "inline void __sync_synchronize(void)\n"
  "{\n"
  "  // WARNING: this was a NOP before gcc 4.3.1,\n"
  "  // but is now believed to be the strongest possible barrier.\n"
  "\n"
  "  #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) >= 40301\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  #endif\n"
  "}\n"
},
{ "getopt",
  "#line 1 \"<builtin-library>-getopt\"\n"
  "\n"
  "extern char *optarg;\n"
  "extern int optind;\n"
  "\n"
  "inline int getopt(int argc, char * const argv[],\n"
  "                  const char *optstring)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int result_index;\n"
  "  __CPROVER_assume(result_index>=0);\n"
  "  (void)*optstring;\n"
  "  if(optind>=argc)\n"
  "    return -1;\n"
  "  __CPROVER_assume(result_index<argc && result_index>=optind);\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(optstring),\n"
  "    \"getopt zero-termination of 3rd argument\");\n"
  "  #endif\n"
  "  optarg = argv[result_index];\n"
  "  optind = result_index+1;\n"
  "  int retval;\n"
  "  return retval;\n"
  "}\n"
},
{ "inet_addr",
  "#line 1 \"<builtin-library>-inet_addr\"\n"
  "\n"
  "#include <arpa/inet.h>\n"
  "\n"
  "in_addr_t inet_addr(const char *cp)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*cp;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(cp), \"inet_addr zero-termination of argument\");\n"
  "  #endif\n"
  "\n"
  "  in_addr_t result;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "inet_aton",
  "#line 1 \"<builtin-library>-inet_aton\"\n"
  "\n"
  "int inet_aton(const char *cp, struct in_addr *pin)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*cp;\n"
  "  (void)*pin;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(cp), \"inet_aton zero-termination of name argument\");\n"
  "  #endif\n"
  "\n"
  "  int result;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "inet_network",
  "#line 1 \"<builtin-library>-inet_network\"\n"
  "\n"
  "in_addr_t inet_network(const char *cp)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*cp;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(cp), \"inet_network zero-termination of name argument\");\n"
  "  #endif\n"
  "\n"
  "  in_addr_t result;\n"
  "  return result;\n"
  "}\n"
  "\n"
  "/* intrin.h is an include file provided by Visual Studio */\n"
  "\n"
},
{ "_InterlockedDecrement",
  "#line 1 \"<builtin-library>-_InterlockedDecrement\"\n"
  "\n"
  "inline long _InterlockedDecrement(long volatile *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // This function generates a full memory barrier (or fence) to ensure that\n"
  "  // memory operations are completed in order.  \n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=--(*p);\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchange",
  "#line 1 \"<builtin-library>-_InterlockedExchange\"\n"
  "\n"
  "inline long _InterlockedExchange(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long old=*p;\n"
  "  *p=v;\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchange16",
  "#line 1 \"<builtin-library>-_InterlockedExchange16\"\n"
  "\n"
  "inline short _InterlockedExchange16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short old=*p;\n"
  "  *p=v;\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchange8",
  "#line 1 \"<builtin-library>-_InterlockedExchange8\"\n"
  "\n"
  "inline char _InterlockedExchange8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char old=*p;\n"
  "  *p=v;\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchangeAdd",
  "#line 1 \"<builtin-library>-_InterlockedExchangeAdd\"\n"
  "\n"
  "inline long _InterlockedExchangeAdd(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchangeAdd16",
  "#line 1 \"<builtin-library>-_InterlockedExchangeAdd16\"\n"
  "\n"
  "inline short _InterlockedExchangeAdd16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=(*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedExchangeAdd8",
  "#line 1 \"<builtin-library>-_InterlockedExchangeAdd8\"\n"
  "\n"
  "inline char _InterlockedExchangeAdd8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char result=(*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedCompareExchange",
  "#line 1 \"<builtin-library>-_InterlockedCompareExchange\"\n"
  "\n"
  "inline long _InterlockedCompareExchange(long volatile *p, long v1, long v2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long old=(*p);\n"
  "  *p=(old==v2)?v1:old;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedCompareExchange64",
  "#line 1 \"<builtin-library>-_InterlockedCompareExchange64\"\n"
  "\n"
  "inline long long _InterlockedCompareExchange64(long long volatile *p, long long v1, long long v2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long long old=(*p);\n"
  "  *p=(old==v2)?v1:old;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "__InterlockedIncrement",
  "#line 1 \"<builtin-library>-__InterlockedIncrement\"\n"
  "\n"
  "inline long _InterlockedIncrement(long volatile *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=++(*p);\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedOr",
  "#line 1 \"<builtin-library>-_InterlockedOr\"\n"
  "\n"
  "inline long _InterlockedOr(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)|=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedOr8",
  "#line 1 \"<builtin-library>-_InterlockedOr8\"\n"
  "\n"
  "inline char _InterlockedOr8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char result=(*p)|=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedOr16",
  "#line 1 \"<builtin-library>-_InterlockedOr16\"\n"
  "\n"
  "inline short _InterlockedOr16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=(*p)|=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedXor",
  "#line 1 \"<builtin-library>-_InterlockedXor\"\n"
  "\n"
  "inline long _InterlockedXor(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)^=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedXor8",
  "#line 1 \"<builtin-library>-_InterlockedXor8\"\n"
  "\n"
  "inline char _InterlockedXor8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char result=(*p)^=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedXor16",
  "#line 1 \"<builtin-library>-_InterlockedXor16\"\n"
  "\n"
  "inline short _InterlockedXor16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=(*p)^=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAnd",
  "#line 1 \"<builtin-library>-_InterlockedAnd\"\n"
  "\n"
  "inline long _InterlockedAnd(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)&=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAnd8",
  "#line 1 \"<builtin-library>-_InterlockedAnd8\"\n"
  "\n"
  "inline char _InterlockedAnd8(char volatile *p, char v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char result=(*p)&=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAnd16",
  "#line 1 \"<builtin-library>-_InterlockedAnd16\"\n"
  "\n"
  "inline short _InterlockedAnd16(short volatile *p, short v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=(*p)&=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAdd",
  "#line 1 \"<builtin-library>-_InterlockedAdd\"\n"
  "\n"
  "inline long _InterlockedAdd(long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  long result=(*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedAddLargeStatistic",
  "#line 1 \"<builtin-library>-_InterlockedAddLargeStatistic\"\n"
  "\n"
  "inline long _InterlockedAddLargeStatistic(long long volatile *p, long v)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // not atomic:\n"
  "  // http://msdn.microsoft.com/en-us/library/yc92ytxy%28v=vs.90%29.aspx\n"
  "  (*p)+=v;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  return v;\n"
  "}\n"
  "\n"
},
{ "_mm_lfence",
  "#line 1 \"<builtin-library>-_mm_lfence\"\n"
  "\n"
  "inline void _mm_lfence(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "}\n"
  "\n"
},
{ "_mm_mfence",
  "#line 1 \"<builtin-library>-_mm_mfence\"\n"
  "\n"
  "inline void _mm_mfence(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
  "\n"
},
{ "_WriteBarrier",
  "#line 1 \"<builtin-library>-_WriteBarrier\"\n"
  "\n"
  "inline void _WriteBarrier(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "}\n"
  "\n"
},
{ "_ReadWriteBarrier",
  "#line 1 \"<builtin-library>-_ReadWriteBarrier\"\n"
  "\n"
  "inline void _ReadWriteBarrier(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
  "\n"
},
{ "_ReadBarrier",
  "#line 1 \"<builtin-library>-_ReadBarrier\"\n"
  "\n"
  "inline void _ReadBarrier(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "}\n"
  "\n"
},
{ "_InterlockedIncrement16",
  "#line 1 \"<builtin-library>-_InterlockedIncrement16\"\n"
  "\n"
  "inline short _InterlockedIncrement16(short volatile *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=++(*p);\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedDecrement16",
  "#line 1 \"<builtin-library>-_InterlockedDecrement16\"\n"
  "\n"
  "inline short _InterlockedDecrement16(short volatile *p)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short result=--(*p);\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "_InterlockedCompareExchange16",
  "#line 1 \"<builtin-library>-_InterlockedCompareExchange16\"\n"
  "\n"
  "inline short _InterlockedCompareExchange16(short volatile *p, short v1, short v2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  short old=(*p);\n"
  "  *p=(old==v2)?v1:old;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "_InterlockedCompareExchange8",
  "#line 1 \"<builtin-library>-_InterlockedCompareExchange8\"\n"
  "\n"
  "inline char _InterlockedCompareExchange8(char volatile *p, char v1, char v2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  char old=(*p);\n"
  "  *p=(old==v2)?v1:old;\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "  __CPROVER_atomic_end();\n"
  "  return old;\n"
  "}\n"
  "\n"
},
{ "fabs",
  "#line 1 \"<builtin-library>-fabs\"\n"
  "\n"
  "inline double fabs(double d) { return __CPROVER_fabs(d); }\n"
  "\n"
},
{ "fabsl",
  "#line 1 \"<builtin-library>-fabsl\"\n"
  "\n"
  "inline long double fabsl(long double d) { return __CPROVER_fabsl(d); }\n"
  "\n"
},
{ "fabsf",
  "#line 1 \"<builtin-library>-fabsf\"\n"
  "\n"
  "inline float fabsf(float f) { return __CPROVER_fabsf(f); }\n"
  "\n"
},
{ "__builtin_fabs",
  "#line 1 \"<builtin-library>-__builtin_fabs\"\n"
  "\n"
  "inline double __builtin_fabs(double d) { return __CPROVER_fabs(d); }\n"
  "\n"
},
{ "__builtin_fabsl",
  "#line 1 \"<builtin-library>-__builtin_fabsl\"\n"
  "\n"
  "inline long double __builtin_fabsl(long double d) { return __CPROVER_fabsl(d); }\n"
  "\n"
},
{ "__builtin_fabsf",
  "#line 1 \"<builtin-library>-__builtin_fabsf\"\n"
  "\n"
  "inline float __builtin_fabsf(float f) { return __CPROVER_fabsf(f); }\n"
  "\n"
},
{ "isfinite",
  "#line 1 \"<builtin-library>-isfinite\"\n"
  "\n"
  "int isfinite(double d) { return __CPROVER_isfinited(d); }\n"
  "\n"
},
{ "__finite",
  "#line 1 \"<builtin-library>-__finite\"\n"
  "\n"
  "int __finite(double d) { return __CPROVER_isfinited(d); }\n"
  "\n"
},
{ "__finitef",
  "#line 1 \"<builtin-library>-__finitef\"\n"
  "\n"
  "int __finitef(float f) { return __CPROVER_isfinitef(f); }\n"
  "\n"
},
{ "__finitel",
  "#line 1 \"<builtin-library>-__finitel\"\n"
  "\n"
  "int __finitel(long double ld) { return __CPROVER_isfiniteld(ld); }\n"
  "\n"
},
{ "isinf",
  "#line 1 \"<builtin-library>-isinf\"\n"
  "\n"
  "inline int isinf(double d) { return __CPROVER_isinfd(d); }\n"
  "\n"
},
{ "__isinf",
  "#line 1 \"<builtin-library>-__isinf\"\n"
  "\n"
  "inline int __isinf(double d) { return __CPROVER_isinfd(d); }\n"
  "\n"
},
{ "isinff",
  "#line 1 \"<builtin-library>-isinff\"\n"
  "\n"
  "inline int isinff(float f) { return __CPROVER_isinff(f); }\n"
  "\n"
},
{ "__isinff",
  "#line 1 \"<builtin-library>-__isinff\"\n"
  "\n"
  "inline int __isinff(float f) { return __CPROVER_isinff(f); }\n"
  "\n"
},
{ "isinfl",
  "#line 1 \"<builtin-library>-isinfl\"\n"
  "\n"
  "inline int isinfl(long double ld) { return __CPROVER_isinfld(ld); }\n"
  "\n"
},
{ "__isinfl",
  "#line 1 \"<builtin-library>-__isinfl\"\n"
  "\n"
  "inline int __isinfl(long double ld) { return __CPROVER_isinfld(ld); }\n"
  "\n"
},
{ "isnan",
  "#line 1 \"<builtin-library>-isnan\"\n"
  "\n"
  "inline int isnan(double d) { return __CPROVER_isnand(d); }\n"
  "\n"
},
{ "__isnan",
  "#line 1 \"<builtin-library>-__isnan\"\n"
  "\n"
  "inline int __isnan(double d) { return __CPROVER_isnand(d); }\n"
  "\n"
},
{ "__isnanf",
  "#line 1 \"<builtin-library>-__isnanf\"\n"
  "\n"
  "inline int __isnanf(float f) { return __CPROVER_isnanf(f); }\n"
  "\n"
},
{ "isnanf",
  "#line 1 \"<builtin-library>-isnanf\"\n"
  "\n"
  "inline int isnanf(float f) { return __CPROVER_isnanf(f); }\n"
  "\n"
},
{ "isnanl",
  "#line 1 \"<builtin-library>-isnanl\"\n"
  "\n"
  "inline int isnanl(long double ld) { return __CPROVER_isnanld(ld); }\n"
  "\n"
},
{ "__isnanl",
  "#line 1 \"<builtin-library>-__isnanl\"\n"
  "\n"
  "inline int __isnanl(long double ld) { return __CPROVER_isnanld(ld); }\n"
  "\n"
},
{ "isnormal",
  "#line 1 \"<builtin-library>-isnormal\"\n"
  "\n"
  "inline int isnormal(double d) { return __CPROVER_isnormald(d); }\n"
  "\n"
},
{ "__isnormalf",
  "#line 1 \"<builtin-library>-__isnormalf\"\n"
  "\n"
  "inline int __isnormalf(float f) { return __CPROVER_isnormalf(f); }\n"
  "\n"
},
{ "__builtin_inff",
  "#line 1 \"<builtin-library>-__builtin_inff\"\n"
  "\n"
  "inline float __builtin_inff(void) { return 1.0f/0.0f; }\n"
  "\n"
},
{ "__builtin_inf",
  "#line 1 \"<builtin-library>-__builtin_inf\"\n"
  "\n"
  "inline double __builtin_inf(void) { return 1.0/0.0; }\n"
  "\n"
},
{ "__builtin_infl",
  "#line 1 \"<builtin-library>-__builtin_infl\"\n"
  "\n"
  "inline long double __builtin_infl(void) { return 1.0l/0.0l; }\n"
  "\n"
},
{ "__builtin_isinf",
  "#line 1 \"<builtin-library>-__builtin_isinf\"\n"
  "\n"
  "inline int __builtin_isinf(double d) { return __CPROVER_isinfd(d); }\n"
  "\n"
},
{ "__builtin_isinff",
  "#line 1 \"<builtin-library>-__builtin_isinff\"\n"
  "\n"
  "inline int __builtin_isinff(float f) { return __CPROVER_isinff(f); }\n"
  "\n"
},
{ "__builtin_isinf",
  "#line 1 \"<builtin-library>-__builtin_isinf\"\n"
  "\n"
  "inline int __builtin_isinfl(long double ld) { return __CPROVER_isinfld(ld); }\n"
  "\n"
},
{ "__builtin_isnan",
  "#line 1 \"<builtin-library>-__builtin_isnan\"\n"
  "\n"
  "inline int __builtin_isnan(double d) { return __CPROVER_isnand(d); }\n"
  "\n"
},
{ "__builtin_isnanf",
  "#line 1 \"<builtin-library>-__builtin_isnanf\"\n"
  "\n"
  "inline int __builtin_isnanf(float f) { return __CPROVER_isnanf(f); }\n"
  "\n"
},
{ "__builtin_huge_valf",
  "#line 1 \"<builtin-library>-__builtin_huge_valf\"\n"
  "\n"
  "inline float __builtin_huge_valf(void) { return 1.0f/0.0f; }\n"
  "\n"
},
{ "__builtin_huge_val",
  "#line 1 \"<builtin-library>-__builtin_huge_val\"\n"
  "\n"
  "inline double __builtin_huge_val(void) { return 1.0/0.0; }\n"
  "\n"
},
{ "__builtin_huge_vall",
  "#line 1 \"<builtin-library>-__builtin_huge_vall\"\n"
  "\n"
  "inline long double __builtin_huge_vall(void) { return 1.0l/0.0l; }\n"
  "\n"
},
{ "_dsign",
  "#line 1 \"<builtin-library>-_dsign\"\n"
  "\n"
  "inline int _dsign(double d) { return __CPROVER_signd(d); }\n"
  "\n"
},
{ "_ldsign",
  "#line 1 \"<builtin-library>-_ldsign\"\n"
  "\n"
  "inline int _ldsign(long double ld) { return __CPROVER_signld(ld); }\n"
  "\n"
},
{ "_fdsign",
  "#line 1 \"<builtin-library>-_fdsign\"\n"
  "\n"
  "inline int _fdsign(float f) { return __CPROVER_signf(f); }\n"
  "\n"
},
{ "signbit",
  "#line 1 \"<builtin-library>-signbit\"\n"
  "\n"
  "inline int signbit(double d) { return __CPROVER_signd(d); }\n"
  "\n"
},
{ "__signbitd",
  "#line 1 \"<builtin-library>-__signbitd\"\n"
  "\n"
  "inline int __signbitd(double d) { return __CPROVER_signd(d); }\n"
  "\n"
},
{ "__signbitf",
  "#line 1 \"<builtin-library>-__signbitf\"\n"
  "\n"
  "inline int __signbitf(float f) { return __CPROVER_signf(f); }\n"
  "\n"
},
{ "__signbit",
  "#line 1 \"<builtin-library>-__signbit\"\n"
  "\n"
  "inline int __signbit(double ld) { return __CPROVER_signld(ld); }\n"
  "\n"
},
{ "_dclass",
  "#line 1 \"<builtin-library>-_dclass\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline short _dclass(double d) {\n"
  "  __CPROVER_HIDE:\n"
  "  return __CPROVER_isnand(d)?FP_NAN:\n"
  "         __CPROVER_isinfd(d)?FP_INFINITE:\n"
  "         d==0?FP_ZERO:\n"
  "         __CPROVER_isnormald(d)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "_ldclass",
  "#line 1 \"<builtin-library>-_ldclass\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline short _ldclass(long double ld) {\n"
  "  __CPROVER_HIDE:\n"
  "  return __CPROVER_isnanld(ld)?FP_NAN:\n"
  "         __CPROVER_isinfld(ld)?FP_INFINITE:\n"
  "         ld==0?FP_ZERO:\n"
  "         __CPROVER_isnormalld(ld)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "_fdclass",
  "#line 1 \"<builtin-library>-_fdclass\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline short _fdclass(float f) {\n"
  "  __CPROVER_HIDE:\n"
  "  return __CPROVER_isnanf(f)?FP_NAN:\n"
  "         __CPROVER_isinff(f)?FP_INFINITE:\n"
  "         f==0?FP_ZERO:\n"
  "         __CPROVER_isnormalf(f)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "__fpclassifyd",
  "#line 1 \"<builtin-library>-__fpclassifyd\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int __fpclassifyd(double d) {\n"
  "  __CPROVER_HIDE:\n"
  "  return __CPROVER_isnand(d)?FP_NAN:\n"
  "         __CPROVER_isinfd(d)?FP_INFINITE:\n"
  "         d==0?FP_ZERO:\n"
  "         __CPROVER_isnormald(d)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "__fpclassifyf",
  "#line 1 \"<builtin-library>-__fpclassifyf\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int __fpclassifyf(float f) {\n"
  "  __CPROVER_HIDE:\n"
  "  return __CPROVER_isnanf(f)?FP_NAN:\n"
  "         __CPROVER_isinff(f)?FP_INFINITE:\n"
  "         f==0?FP_ZERO:\n"
  "         __CPROVER_isnormalf(f)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "__fpclassifyl",
  "#line 1 \"<builtin-library>-__fpclassifyl\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int __fpclassifyl(long double f) {\n"
  "  __CPROVER_HIDE:\n"
  "  return __CPROVER_isnanld(f)?FP_NAN:\n"
  "         __CPROVER_isinfld(f)?FP_INFINITE:\n"
  "         f==0?FP_ZERO:\n"
  "         __CPROVER_isnormalld(f)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "\n"
},
{ "__fpclassify",
  "#line 1 \"<builtin-library>-__fpclassify\"\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// The variant with long double below is needed for older Macs\n"
  "// only; newer ones use __fpclassifyd.\n"
  "\n"
  "#ifdef __APPLE__\n"
  "inline int __fpclassify(long double d) {\n"
  "  __CPROVER_HIDE:\n"
  "  return __CPROVER_isnanld(d)?FP_NAN:\n"
  "         __CPROVER_isinfld(d)?FP_INFINITE:\n"
  "         d==0?FP_ZERO:\n"
  "         __CPROVER_isnormalld(d)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "#else\n"
  "inline int __fpclassify(double d) {\n"
  "  __CPROVER_HIDE:\n"
  "  return __CPROVER_isnand(d)?FP_NAN:\n"
  "         __CPROVER_isinfd(d)?FP_INFINITE:\n"
  "         d==0?FP_ZERO:\n"
  "         __CPROVER_isnormald(d)?FP_NORMAL:\n"
  "         FP_SUBNORMAL;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "sin",
  "#line 1 \"<builtin-library>-sin\"\n"
  "\n"
  "double sin(double x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  double ret;\n"
  "\n"
  "  if(__CPROVER_isinfd(x) || __CPROVER_isnand(x))\n"
  "    __CPROVER_assume(__CPROVER_isnand(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==0);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "sinl",
  "#line 1 \"<builtin-library>-sinl\"\n"
  "\n"
  "long double sinl(long double x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  long double ret;\n"
  "\n"
  "  if(__CPROVER_isinfld(x) || __CPROVER_isnanld(x))\n"
  "    __CPROVER_assume(__CPROVER_isnanld(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==0);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "sinf",
  "#line 1 \"<builtin-library>-sinf\"\n"
  "\n"
  "float sinf(float x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  float ret;\n"
  "\n"
  "  if(__CPROVER_isinff(x) || __CPROVER_isnanf(x))\n"
  "    __CPROVER_assume(__CPROVER_isnanf(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==0);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "cos",
  "#line 1 \"<builtin-library>-cos\"\n"
  "\n"
  "double cos(double x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  double ret;\n"
  "\n"
  "  if(__CPROVER_isinfd(x) || __CPROVER_isnand(x))\n"
  "    __CPROVER_assume(__CPROVER_isnand(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==1);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "cosl",
  "#line 1 \"<builtin-library>-cosl\"\n"
  "\n"
  "long double cosl(long double x)\n"
  "{\n"
  "  // gross over-approximation\n"
  "  long double ret;\n"
  "\n"
  "  if(__CPROVER_isinfld(x) || __CPROVER_isnanld(x))\n"
  "    __CPROVER_assume(__CPROVER_isnanld(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==1);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "cosf",
  "#line 1 \"<builtin-library>-cosf\"\n"
  "\n"
  "float cosf(float x)\n"
  "{\n"
  "__CPROVER_hide:;\n"
  "  // gross over-approximation\n"
  "  float ret;\n"
  "\n"
  "  if(__CPROVER_isinff(x) || __CPROVER_isnanf(x))\n"
  "    __CPROVER_assume(__CPROVER_isnanf(ret));\n"
  "  else\n"
  "  {\n"
  "    __CPROVER_assume(ret<=1);\n"
  "    __CPROVER_assume(ret>=-1);\n"
  "    __CPROVER_assume(x!=0 || ret==1);\n"
  "  }\n"
  "\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "__builtin_nan",
  "#line 1 \"<builtin-library>-__builtin_nan\"\n"
  "\n"
  "double __builtin_nan(const char *str)\n"
  "{\n"
  "  // the 'str' argument is not yet used\n"
  "__CPROVER_hide:;\n"
  "  (void)*str;\n"
  "  return 0.0/0.0;\n"
  "}\n"
  "\n"
},
{ "__builtin_nanf",
  "#line 1 \"<builtin-library>-__builtin_nanf\"\n"
  "\n"
  "float __builtin_nanf(const char *str)\n"
  "{\n"
  "  // the 'str' argument is not yet used\n"
  "__CPROVER_hide:;\n"
  "  (void)*str;\n"
  "  return 0.0/0.0;\n"
  "}\n"
  "\n"
},
{ "nextUpf",
  "#line 1 \"<builtin-library>-nextUpf\"\n"
  "\n"
  "#ifndef __CPROVER_LIMITS_H_INCLUDED\n"
  "#include <limits.h>\n"
  "#define __CPROVER_LIMITS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "\n"
  "// IEEE_754 2008 althought similar to C's nextafter / nexttowards\n"
  "// Loosely assumes that float is (IEEE-754) binary32\n"
  "\n"
  "union mixf\n"
  "{\n"
  "  float f;\n"
  "  #ifdef LIBRARY_CHECK\n"
  "  int bv;\n"
  "  #else\n"
  "  __CPROVER_bitvector[CHAR_BIT * sizeof(float)] bv;\n"
  "  #endif\n"
  "};\n"
  "\n"
  "float nextUpf(float f)\n"
  "{\n"
  "__CPROVER_hide:;\n"
  "  if (__CPROVER_isnanf(f))\n"
  "    return 0.0f/0.0f;  // NaN\n"
  "  else if (f == 0.0f)\n"
  "    return 0x1p-149f;\n"
  "  else if (f > 0.0f)\n"
  "  {\n"
  "    if (__CPROVER_isinff(f))\n"
  "      return f;\n"
  "\n"
  "    union mixf m;\n"
  "    m.f = f;\n"
  "    ++m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(f < 0.0f);\n"
  "\n"
  "    union mixf m;\n"
  "    m.f = f;\n"
  "    --m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "nextUp",
  "#line 1 \"<builtin-library>-nextUp\"\n"
  "\n"
  "#ifndef __CPROVER_LIMITS_H_INCLUDED\n"
  "#include <limits.h>\n"
  "#define __CPROVER_LIMITS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "\n"
  "// IEEE_754 2008 althought similar to C's nextafter / nexttowards\n"
  "// Loosely assumes that double is (IEEE-754) binary64\n"
  "\n"
  "union mixd\n"
  "{\n"
  "  double f;\n"
  "  #ifdef LIBRARY_CHECK\n"
  "  long long int bv;\n"
  "  #else\n"
  "  __CPROVER_bitvector[CHAR_BIT * sizeof(double)] bv;\n"
  "  #endif\n"
  "};\n"
  "\n"
  "double nextUp(double d)\n"
  "{\n"
  "__CPROVER_hide:;\n"
  "  if (__CPROVER_isnand(d))\n"
  "    return 0.0/0.0;  // NaN\n"
  "  else if (d == 0.0)\n"
  "    return 0x1.0p-1074;\n"
  "  else if (d > 0.0)\n"
  "  {\n"
  "    if (__CPROVER_isinfd(d))\n"
  "      return d;\n"
  "\n"
  "    union mixd m;\n"
  "    m.f = d;\n"
  "    ++m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(d < 0.0);\n"
  "\n"
  "    union mixd m;\n"
  "    m.f = d;\n"
  "    --m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "}\n"
  "\n"
  "\n"
},
{ "nextUpl",
  "#line 1 \"<builtin-library>-nextUpl\"\n"
  "\n"
  "#ifndef __CPROVER_LIMITS_H_INCLUDED\n"
  "#include <limits.h>\n"
  "#define __CPROVER_LIMITS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// IEEE_754 2008 althought similar to C's nextafter / nexttowards\n"
  "\n"
  "union mixl\n"
  "{\n"
  "  long double f;\n"
  "  #ifdef LIBRARY_CHECK\n"
  "  long long int bv;\n"
  "  #else\n"
  "  __CPROVER_bitvector[CHAR_BIT * sizeof(long double)] bv;\n"
  "  #endif\n"
  "};\n"
  "\n"
  "long double nextUpl(long double d)\n"
  "{\n"
  "__CPROVER_hide:;\n"
  "  if(__CPROVER_isnanld(d))\n"
  "    return 0.0/0.0;  // NaN\n"
  "  else if (d == 0.0)\n"
  "  {\n"
  "    union mixl m;\n"
  "    m.bv = 0x1;\n"
  "    return m.f;\n"
  "  }\n"
  "  else if (d > 0.0)\n"
  "  {\n"
  "    if(__CPROVER_isinfld(d))\n"
  "      return d;\n"
  "\n"
  "    union mixl m;\n"
  "    m.f = d;\n"
  "    ++m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(d < 0.0);\n"
  "\n"
  "    union mixl m;\n"
  "    m.f = d;\n"
  "    --m.bv;\n"
  "    return m.f;\n"
  "  }\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "\n"
},
{ "sqrtf",
  "#line 1 \"<builtin-library>-sqrtf\"\n"
  "\n"
  "/* This code is *WRONG* in some circumstances, specifically:\n"
  " *\n"
  " *   1. If run with a rounding mode other than RNE the\n"
  " *      answer will be out by one or two ULP.  This could be fixed\n"
  " *      with careful choice of round mode for the multiplications.\n"
  " *\n"
  " *   2. Subnormals have the unusual property that there are\n"
  " *      multiple numbers that square to give them.  I.E. if\n"
  " *      f is subnormal then there are multiple f1 != f2 such that\n"
  " *      f1 * f1 == f == f2 * f2.  This code will return *a*\n"
  " *      square root of a subnormal input but not necessarily *the*\n"
  " *      square root (i.e. the real value of the square root rounded).\n"
  " */\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "float nextUpf(float f);\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "float sqrtf(float f)\n"
  "{\n"
  " __CPROVER_hide:;\n"
  "\n"
  "  if ( f < 0.0f )\n"
  "    return 0.0f/0.0f; // NaN\n"
  "  else if (__CPROVER_isinff(f) ||   // +Inf only\n"
  "	   f == 0.0f          ||   // Includes -0\n"
  "	   __CPROVER_isnanf(f))\n"
  "    return f;\n"
  "  else if (__CPROVER_isnormalf(f))\n"
  "  {\n"
  "    float lower;    // Intentionally non-deterministic\n"
  "    __CPROVER_assume(lower > 0.0f);\n"
  "    __CPROVER_assume(__CPROVER_isnormalf(lower));\n"
  "    // Tighter bounds can be given but are dependent on the\n"
  "    // number of exponent and significand bits.  Thus they are\n"
  "    // given implicitly...\n"
  "\n"
  "    float lowerSquare = lower * lower;\n"
  "    __CPROVER_assume(__CPROVER_isnormalf(lowerSquare));\n"
  "\n"
  "    float upper = nextUpf(lower);\n"
  "    float upperSquare = upper * upper;  // Might be +Inf\n"
  "\n"
  "    // Restrict these to bound f and thus compute the possible\n"
  "    // values for the square root.  Note that the lower bound \n"
  "    // can be equal, this is important to catch edge cases such as\n"
  "    // 0x1.fffffep+127f and relies on the smallest normal number\n"
  "    // being a perfect square (which it will be for any sensible\n"
  "    // bit width).\n"
  "    __CPROVER_assume(lowerSquare <= f);\n"
  "    __CPROVER_assume(f < upperSquare);\n"
  "\n"
  "    // Select between them to work out which to return\n"
  "    switch(__CPROVER_rounding_mode)\n"
  "    {\n"
  "    case FE_TONEAREST :\n"
  "      return (f - lowerSquare < upperSquare - f) ? lower : upper; break;\n"
  "    case FE_UPWARD :\n"
  "      return (f - lowerSquare == 0.0f) ? lower : upper; break;\n"
  "    case FE_DOWNWARD : // Fall through\n"
  "    case FE_TOWARDZERO :\n"
  "      return (f - lowerSquare == 0.0f) ? lower : upper; break;\n"
  "    default:;\n"
  "      //assert(0);\n"
  "    }\n"
  "\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(fpclassify(f) == FP_SUBNORMAL);\n"
  "    //assert(f > 0.0f);\n"
  "\n"
  "    // With respect to the algebra of floating point number\n"
  "    // all subnormals seem to be perfect squares, thus ...\n"
  "\n"
  "    float root;    // Intentionally non-deterministic\n"
  "    __CPROVER_assume(root >= 0.0f);\n"
  "\n"
  "    __CPROVER_assume(root * root == f);\n"
  "\n"
  "    return root;\n"
  "  }\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "\n"
},
{ "sqrt",
  "#line 1 \"<builtin-library>-sqrt\"\n"
  "\n"
  "/* The same caveats as sqrtf apply */\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "double nextUp(double d);\n"
  "\n"
  "double sqrt(double d)\n"
  "{\n"
  " __CPROVER_hide:;\n"
  "\n"
  "  if ( d < 0.0 )\n"
  "    return 0.0/0.0; // NaN\n"
  "  else if (__CPROVER_isinfd(d) ||   // +Inf only\n"
  "	   d == 0.0            ||   // Includes -0\n"
  "	   __CPROVER_isnand(d))\n"
  "    return d;\n"
  "  else if (__CPROVER_isnormald(d))\n"
  "  {\n"
  "    double lower;    // Intentionally non-deterministic\n"
  "    __CPROVER_assume(lower > 0.0);\n"
  "    __CPROVER_assume(__CPROVER_isnormald(lower));\n"
  "\n"
  "    double lowerSquare = lower * lower;\n"
  "    __CPROVER_assume(__CPROVER_isnormald(lowerSquare));\n"
  "\n"
  "    double upper = nextUp(lower);\n"
  "    double upperSquare = upper * upper;  // Might be +Inf\n"
  "\n"
  "    __CPROVER_assume(lowerSquare <= d);\n"
  "    __CPROVER_assume(d < upperSquare);\n"
  "\n"
  "    switch(__CPROVER_rounding_mode)\n"
  "    {\n"
  "    case FE_TONEAREST:\n"
  "      return (d - lowerSquare < upperSquare - d) ? lower : upper; break;\n"
  "    case FE_UPWARD:\n"
  "      return (d - lowerSquare == 0.0f) ? lower : upper; break;\n"
  "    case FE_DOWNWARD: // Fall through\n"
  "    case FE_TOWARDZERO:\n"
  "      return (d - lowerSquare == 0.0) ? lower : upper; break;\n"
  "    default:;\n"
  "      //assert(0);\n"
  "    }\n"
  "\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(fpclassify(d) == FP_SUBNORMAL);\n"
  "    //assert(d > 0.0);\n"
  "\n"
  "    double root;    // Intentionally non-deterministic\n"
  "    __CPROVER_assume(root >= 0.0);\n"
  "\n"
  "    __CPROVER_assume(root * root == d);\n"
  "\n"
  "    return root;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "sqrtl",
  "#line 1 \"<builtin-library>-sqrtl\"\n"
  "\n"
  "/* The same caveats as sqrtf apply */\n"
  "\n"
  "#ifndef __CPROVER_MATH_H_INCLUDED\n"
  "#include <math.h>\n"
  "#define __CPROVER_MATH_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_FENV_H_INCLUDED\n"
  "#include <fenv.h>\n"
  "#define __CPROVER_FENV_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "long double nextUpl(long double d);\n"
  "\n"
  "long double sqrtl(long double d)\n"
  "{\n"
  " __CPROVER_hide:;\n"
  "\n"
  "  if(d < 0.0l)\n"
  "    return 0.0l/0.0l; // NaN\n"
  "  else if (__CPROVER_isinfld(d) ||   // +Inf only\n"
  "	   d == 0.0l            ||   // Includes -0\n"
  "	   __CPROVER_isnanld(d))\n"
  "    return d;\n"
  "  else if (__CPROVER_isnormalld(d))\n"
  "  {\n"
  "    long double lower;    // Intentionally non-deterministic\n"
  "    __CPROVER_assume(lower > 0.0l);\n"
  "    __CPROVER_assume(__CPROVER_isnormalld(lower));\n"
  "\n"
  "    long double lowerSquare = lower * lower;\n"
  "    __CPROVER_assume(__CPROVER_isnormalld(lowerSquare));\n"
  "\n"
  "    long double upper = nextUpl(lower);\n"
  "    long double upperSquare = upper * upper;  // Might be +Inf\n"
  "\n"
  "    __CPROVER_assume(lowerSquare <= d);\n"
  "    __CPROVER_assume(d < upperSquare);\n"
  "\n"
  "    switch(__CPROVER_rounding_mode)\n"
  "    {\n"
  "    case FE_TONEAREST:\n"
  "      return (d - lowerSquare < upperSquare - d) ? lower : upper; break;\n"
  "    case FE_UPWARD:\n"
  "      return (d - lowerSquare == 0.0l) ? lower : upper; break;\n"
  "    case FE_DOWNWARD: // Fall through\n"
  "    case FE_TOWARDZERO:\n"
  "      return (d - lowerSquare == 0.0l) ? lower : upper; break;\n"
  "    default:;\n"
  "      //assert(0);\n"
  "    }\n"
  "\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    //assert(fpclassify(d) == FP_SUBNORMAL);\n"
  "    //assert(d > 0.0l);\n"
  "\n"
  "    long double root;    // Intentionally non-deterministic\n"
  "    __CPROVER_assume(root >= 0.0l);\n"
  "\n"
  "    __CPROVER_assume(root * root == d);\n"
  "\n"
  "    return root;\n"
  "  }\n"
  "}\n"
},
{ "gethostbyname",
  "#line 1 \"<builtin-library>-gethostbyname\"\n"
  "\n"
  "#include <netdb.h>\n"
  "\n"
  "struct hostent *gethostbyname(const char *name)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*name;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(name), \"gethostbyname zero-termination of name argument\");\n"
  "  #endif\n"
  "\n"
  "  __CPROVER_bool error;\n"
  "  if(error) return 0;\n"
  "  \n"
  "  // quite restrictive, as will alias between calls\n"
  "  static struct hostent result;\n"
  "  \n"
  "  // we whould be filling in the fields of this\n"
  "  return &result;\n"
  "}\n"
  "\n"
},
{ "gethostbyaddr",
  "#line 1 \"<builtin-library>-gethostbyaddr\"\n"
  "\n"
  "struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*(char*)addr;\n"
  "  (void)len;\n"
  "  (void)type;\n"
  "\n"
  "  __CPROVER_bool error;\n"
  "  if(error) return 0;\n"
  "  \n"
  "  // quite restrictive, as will alias between calls\n"
  "  static struct hostent result;\n"
  "  \n"
  "  // we whould be filling in the fields of this\n"
  "  return &result;\n"
  "}\n"
  "\n"
},
{ "gethostent",
  "#line 1 \"<builtin-library>-gethostent\"\n"
  "\n"
  "struct hostent *gethostent(void)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  __CPROVER_bool error;\n"
  "  if(error) return 0;\n"
  "  \n"
  "  // quite restrictive, as will alias between calls\n"
  "  static struct hostent result;\n"
  "  \n"
  "  // we whould be filling in the fields of this\n"
  "  return &result;\n"
  "}\n"
},
{ "__new",
  "#line 1 \"<builtin-library>-__new\"\n"
  "\n"
  "inline void *__new(__typeof__(sizeof(int)) malloc_size)\n"
  "{\n"
  "  // The constructor call is done by the front-end.\n"
  "  // This just does memory allocation.\n"
  "  __CPROVER_HIDE:;\n"
  "  void *res;\n"
  "  res=__CPROVER_malloc(malloc_size);\n"
  "\n"
  "  // ensure it's not recorded as deallocated\n"
  "  __CPROVER_deallocated=(res==__CPROVER_deallocated)?0:__CPROVER_deallocated;\n"
  "  \n"
  "  // non-derministically record the object size for bounds checking\n"
  "  __CPROVER_bool record_malloc;\n"
  "  __CPROVER_malloc_object=record_malloc?res:__CPROVER_malloc_object;\n"
  "  __CPROVER_malloc_size=record_malloc?malloc_size:__CPROVER_malloc_size;\n"
  "  __CPROVER_malloc_is_new_array=record_malloc?0:__CPROVER_malloc_is_new_array;\n"
  "  \n"
  "  // detect memory leaks\n"
  "  __CPROVER_bool record_may_leak;\n"
  "  __CPROVER_memory_leak=record_may_leak?res:__CPROVER_memory_leak;\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "__new_array",
  "#line 1 \"<builtin-library>-__new_array\"\n"
  "\n"
  "#undef malloc\n"
  "void *malloc(__CPROVER_size_t malloc_size);\n"
  "\n"
  "inline void *__new_array(__CPROVER_size_t count, __CPROVER_size_t size)\n"
  "{\n"
  "  // The constructor call is done by the front-end.\n"
  "  // This just does memory allocation.\n"
  "  __CPROVER_HIDE:;\n"
  "  void *res;\n"
  "  res=__CPROVER_malloc(size*count);\n"
  "\n"
  "  // ensure it's not recorded as deallocated\n"
  "  __CPROVER_deallocated=(res==__CPROVER_deallocated)?0:__CPROVER_deallocated;\n"
  "  \n"
  "  // non-deterministically record the object size for bounds checking\n"
  "  __CPROVER_bool record_malloc;\n"
  "  __CPROVER_malloc_object=record_malloc?res:__CPROVER_malloc_object;\n"
  "  __CPROVER_malloc_size=record_malloc?size*count:__CPROVER_malloc_size;\n"
  "  __CPROVER_malloc_is_new_array=record_malloc?1:__CPROVER_malloc_is_new_array;\n"
  "  \n"
  "  // detect memory leaks\n"
  "  __CPROVER_bool record_may_leak;\n"
  "  __CPROVER_memory_leak=record_may_leak?res:__CPROVER_memory_leak;\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "__placement_new",
  "#line 1 \"<builtin-library>-__placement_new\"\n"
  "\n"
  "inline void *__placement_new(__typeof__(sizeof(int)) malloc_size, void *p)\n"
  "{\n"
  "  // The constructor call is done by the front-end.\n"
  "  // The allocation is done by the user. So this does nothing.\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)malloc_size;\n"
  "  return p;\n"
  "}\n"
  "\n"
},
{ "__delete",
  "#line 1 \"<builtin-library>-__delete\"\n"
  "\n"
  "inline void __delete(void *ptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // If ptr is NULL, no operation is performed.\n"
  "  // This is a requirement by the standard, not generosity!\n"
  "  if(ptr!=0)\n"
  "  {\n"
  "    // is it dynamic?\n"
  "    __CPROVER_assert(__CPROVER_DYNAMIC_OBJECT(ptr),\n"
  "                     \"delete argument must be dynamic object\");\n"
  "    __CPROVER_assert(__CPROVER_POINTER_OFFSET(ptr)==0,\n"
  "                     \"delete argument must have offset zero\");\n"
  "\n"
  "    // catch double delete\n"
  "    __CPROVER_assert(__CPROVER_deallocated!=ptr, \"double delete\");\n"
  "    \n"
  "    // catch people who call delete for objects allocated with new[]\n"
  "    __CPROVER_assert(__CPROVER_malloc_object!=ptr ||\n"
  "                     !__CPROVER_malloc_is_new_array,\n"
  "                     \"delete of array object\");\n"
  "    \n"
  "    // non-deterministically record as deallocated\n"
  "    __CPROVER_bool record;\n"
  "    __CPROVER_deallocated=record?ptr:__CPROVER_deallocated;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "__delete_array",
  "#line 1 \"<builtin-library>-__delete_array\"\n"
  "\n"
  "inline void __delete_array(void *ptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // If ptr is NULL, no operation is performed.\n"
  "  // This is a requirement by the standard, not generosity!\n"
  "  if(ptr!=0)\n"
  "  {\n"
  "    // is it dynamic?\n"
  "    __CPROVER_assert(__CPROVER_DYNAMIC_OBJECT(ptr),\n"
  "                     \"delete argument must be dynamic object\");\n"
  "    __CPROVER_assert(__CPROVER_POINTER_OFFSET(ptr)==0,\n"
  "                     \"delete argument must have offset zero\");\n"
  "\n"
  "    // catch double delete\n"
  "    __CPROVER_assert(__CPROVER_deallocated!=ptr, \"double delete\");\n"
  "    \n"
  "    // catch people who call delete[] for objects allocated with new\n"
  "    __CPROVER_assert(__CPROVER_malloc_object!=ptr ||\n"
  "                     __CPROVER_malloc_is_new_array,\n"
  "                     \"delete[] of non-array object\");\n"
  "\n"
  "    // non-deterministically record as deallocated\n"
  "    __CPROVER_bool record;\n"
  "    __CPROVER_deallocated=record?ptr:__CPROVER_deallocated;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "__noop",
  "#line 1 \"<builtin-library>-__noop\"\n"
  "\n"
  "int __noop()\n"
  "{\n"
  "  // does nothing\n"
  "  return 0;\n"
  "}\n"
},
{ "_beginthread",
  "#line 1 \"<builtin-library>-_beginthread\"\n"
  "\n"
  "__CPROVER_size_t _beginthread( \n"
  "  void (*start_address)(void *),\n"
  "  unsigned stack_size,\n"
  "  void *arglist)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_ASYNC_1: start_address(arglist);\n"
  "  (void)stack_size;\n"
  "  __CPROVER_size_t handle;\n"
  "  return handle;\n"
  "}\n"
  "\n"
},
{ "_beginthreadex",
  "#line 1 \"<builtin-library>-_beginthreadex\"\n"
  "\n"
  "__CPROVER_size_t _beginthreadex( \n"
  "   void *security,\n"
  "   unsigned stack_size,\n"
  "   unsigned (*start_address )(void *),\n"
  "   void *arglist,\n"
  "   unsigned initflag,\n"
  "   unsigned *thrdaddr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_ASYNC_1: start_address(arglist);\n"
  "  if(security)\n"
  "    (void)*(char*)security;\n"
  "  (void)stack_size;\n"
  "  (void)initflag;\n"
  "  (void)*thrdaddr;\n"
  "  __CPROVER_size_t handle;\n"
  "  return handle;\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_init",
  "#line 1 \"<builtin-library>-pthread_mutex_init\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_init(\n"
  "  pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  *((signed char *)mutex)=0;\n"
  "  if(mutexattr!=0) (void)*mutexattr;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_lock",
  "#line 1 \"<builtin-library>-pthread_mutex_lock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_lock(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assert(*((signed char *)mutex)!=-1,\n"
  "    \"mutex not initialised or destroyed\");\n"
  "  __CPROVER_assume(!*((signed char *)mutex));\n"
  "  *((signed char *)mutex)=1;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_trylock",
  "#line 1 \"<builtin-library>-pthread_mutex_trylock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_trylock(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  __CPROVER_atomic_begin();\n"
  "\n"
  "  __CPROVER_assert(*((signed char *)mutex)!=-1,\n"
  "    \"mutex not initialised or destroyed\");\n"
  "\n"
  "  if(*((signed char *)mutex)==1)\n"
  "  {\n"
  "    // failed\n"
  "    return_value=1;\n"
  "  }\n"
  "  else\n"
  "  {\n"
  "    // ok\n"
  "    return_value=0;\n"
  "    *((signed char *)mutex)=1;\n"
  "  }\n"
  "\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_unlock",
  "#line 1 \"<builtin-library>-pthread_mutex_unlock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_unlock(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // the fence must be before the unlock\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                    \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assert(*((signed char *)mutex)==1,\n"
  "    \"must hold lock upon unlock\");\n"
  "  *((signed char *)mutex)=0;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_mutex_destroy",
  "#line 1 \"<builtin-library>-pthread_mutex_destroy\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_mutex_destroy(pthread_mutex_t *mutex)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_assert(*((signed char *)mutex)==0,\n"
  "    \"lock held upon destroy\");\n"
  "  *((signed char *)mutex)=-1;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_exit",
  "#line 1 \"<builtin-library>-pthread_exit\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern __CPROVER_bool __CPROVER_threads_exited[];\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_thread_id;\n"
  "\n"
  "inline void pthread_exit(void *value_ptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if(value_ptr!=0) (void)*(char*)value_ptr;\n"
  "  __CPROVER_threads_exited[__CPROVER_thread_id]=1;\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "\n"
},
{ "pthread_join",
  "#line 1 \"<builtin-library>-pthread_join\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern __CPROVER_bool __CPROVER_threads_exited[];\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_thread_id;\n"
  "extern unsigned long __CPROVER_next_thread_id;\n"
  "\n"
  "inline int pthread_join(pthread_t thread, void **value_ptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if((unsigned long)thread>__CPROVER_next_thread_id) return ESRCH;\n"
  "  if((unsigned long)thread==__CPROVER_thread_id) return EDEADLK;\n"
  "  if(value_ptr!=0) (void)**(char**)value_ptr;\n"
  "  __CPROVER_assume(__CPROVER_threads_exited[(unsigned long)thread]);\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_destroy",
  "#line 1 \"<builtin-library>-pthread_rwlock_destroy\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_destroy(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_assert(*((signed char *)lock)==0,\n"
  "    \"lock held upon destroy\");\n"
  "  *((signed char *)lock)=-1;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_init",
  "#line 1 \"<builtin-library>-pthread_rwlock_init\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_init(pthread_rwlock_t *lock, \n"
  "  const pthread_rwlockattr_t *attr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (*(signed char *)lock)=0;\n"
  "  if(attr!=0) (void)*attr;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_rdlock",
  "#line 1 \"<builtin-library>-pthread_rwlock_rdlock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_rdlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assert(*((signed char *)lock)!=-1,\n"
  "    \"lock not initialised or destroyed\");\n"
  "  __CPROVER_assume(!*((signed char *)lock));\n"
  "  *((signed char *)lock)=1;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_tryrdlock",
  "#line 1 \"<builtin-library>-pthread_rwlock_tryrdlock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if((*(signed char *)lock & 2)!=0) { __CPROVER_atomic_end(); return 1; }\n"
  "  (*(signed char *)lock)|=1;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_trywrlock",
  "#line 1 \"<builtin-library>-pthread_rwlock_trywrlock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_trywrlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(*(signed char *)lock) { __CPROVER_atomic_end(); return 1; }\n"
  "  (*(signed char *)lock)=2;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_unlock",
  "#line 1 \"<builtin-library>-pthread_rwlock_unlock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_unlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_assert(*((signed char *)lock)==1,\n"
  "    \"must hold lock upon unlock\");\n"
  "  // TODO: unlocks all held locks at once\n"
  "  *((signed char *)lock)=0;\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_rwlock_wrlock",
  "#line 1 \"<builtin-library>-pthread_rwlock_wrlock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_rwlock_wrlock(pthread_rwlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assert(*((signed char *)lock)!=-1,\n"
  "    \"lock not initialised or destroyed\");\n"
  "  __CPROVER_assume(!*((signed char *)lock));\n"
  "  *((signed char *)lock)=2;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_create",
  "#line 1 \"<builtin-library>-pthread_create\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern __CPROVER_bool __CPROVER_threads_exited[];\n"
  "extern __CPROVER_thread_local unsigned long __CPROVER_thread_id;\n"
  "extern unsigned long __CPROVER_next_thread_id;\n"
  "\n"
  "// using separate function avoid unnecessary copies of local variables\n"
  "// from functions invoking pthread_create, don't inline!\n"
  "void __actual_thread_spawn(\n"
  "  void * (*start_routine)(void *),\n"
  "  void *arg,\n"
  "  unsigned long id)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_ASYNC_1: __CPROVER_thread_id=id,\n"
  "                       start_routine(arg),\n"
  "                       __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                                       \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\"),\n"
  "                       __CPROVER_threads_exited[id]=1;\n"
  "}\n"
  "\n"
  "int pthread_create(\n"
  "  pthread_t *thread,\n"
  "  const pthread_attr_t *attr,\n"
  "  void * (*start_routine)(void *),\n"
  "  void *arg)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  unsigned long this_thread_id;\n"
  "  __CPROVER_atomic_begin();\n"
  "  this_thread_id=++__CPROVER_next_thread_id;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  if(thread)\n"
  "  {\n"
  "    #ifdef __APPLE__\n"
  "    // pthread_t is a pointer type on the Mac\n"
  "    *thread=(pthread_t)this_thread_id;\n"
  "    #else\n"
  "    *thread=this_thread_id;\n"
  "    #endif\n"
  "  }\n"
  "\n"
  "  if(attr) (void)*attr;\n"
  "  __actual_thread_spawn(start_routine, arg, this_thread_id);\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_cond_init",
  "#line 1 \"<builtin-library>-pthread_cond_init\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_cond_init(\n"
  "    pthread_cond_t *cond,\n"
  "    const pthread_condattr_t *attr)\n"
  "{ __CPROVER_HIDE:\n"
  "  *((unsigned *)cond)=0;\n"
  "  if(attr) (void)*attr;\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_cond_signal",
  "#line 1 \"<builtin-library>-pthread_cond_signal\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_cond_signal(\n"
  "    pthread_cond_t *cond)\n"
  "{ __CPROVER_HIDE:\n"
  "  __CPROVER_atomic_begin();\n"
  "  (*((unsigned *)cond))++;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_cond_broadcast",
  "#line 1 \"<builtin-library>-pthread_cond_broadcast\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_cond_broadcast(\n"
  "    pthread_cond_t *cond)\n"
  "{ __CPROVER_HIDE:\n"
  "  __CPROVER_atomic_begin();\n"
  "  *((unsigned *)cond)=(unsigned)-1;\n"
  "  __CPROVER_atomic_end();\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "pthread_cond_wait",
  "#line 1 \"<builtin-library>-pthread_cond_wait\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int pthread_cond_wait(\n"
  "    pthread_cond_t *cond,\n"
  "    pthread_mutex_t *mutex)\n"
  "{ __CPROVER_HIDE:\n"
  "  pthread_mutex_unlock(mutex);\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assume(*((unsigned *)cond));\n"
  "  (*((unsigned *)cond))--;\n"
  "  __CPROVER_atomic_end();\n"
  "  pthread_mutex_lock(mutex);\n"
  "  return 0; // we never fail\n"
  "}\n"
  "\n"
},
{ "pthread_spin_lock",
  "#line 1 \"<builtin-library>-pthread_spin_lock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// no pthread_spinlock_t on the Mac\n"
  "#ifndef __APPLE__\n"
  "int pthread_spin_lock(pthread_spinlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assume(!*((unsigned *)lock));\n"
  "  (*((unsigned *)lock))=1;\n"
  "  __CPROVER_atomic_end();\n"
  "  \n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  return 0;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "pthread_spin_unlock",
  "#line 1 \"<builtin-library>-pthread_spin_unlock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// no pthread_spinlock_t on the Mac\n"
  "#ifndef __APPLE__\n"
  "int pthread_spin_unlock(pthread_spinlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // This is atomic_full_barrier() in glibc.\n"
  "  // The fence must be before the unlock.\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  *((unsigned *)lock) = 0;\n"
  "  return 0;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "pthread_spin_trylock",
  "#line 1 \"<builtin-library>-pthread_spin_trylock\"\n"
  "\n"
  "#ifndef __CPROVER_PTHREAD_H_INCLUDED\n"
  "#include <pthread.h>\n"
  "#define __CPROVER_PTHREAD_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "// no pthread_spinlock_t on the Mac\n"
  "#ifndef __APPLE__\n"
  "int pthread_spin_trylock(pthread_spinlock_t *lock)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int result;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(*((unsigned *)lock))\n"
  "    result=EBUSY;\n"
  "  else\n"
  "  {\n"
  "    result=0;\n"
  "    (*((unsigned *)lock))=1;\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "  \n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\",\n"
  "                  \"WWcumul\", \"RRcumul\", \"RWcumul\", \"WRcumul\");\n"
  "  return result;\n"
  "}\n"
  "#endif\n"
  "\n"
  "\n"
},
{ "longjmp",
  "#line 1 \"<builtin-library>-longjmp\"\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#include <setjmp.h>\n"
  "#define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline void longjmp(jmp_buf env, int val)\n"
  "{\n"
  "  // does not return\n"
  "  (void)env;\n"
  "  (void)val;\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "       \n"
},
{ "_longjmp",
  "#line 1 \"<builtin-library>-_longjmp\"\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#include <setjmp.h>\n"
  "#define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline void _longjmp(jmp_buf env, int val)\n"
  "{\n"
  "  // does not return\n"
  "  (void)env;\n"
  "  (void)val;\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "       \n"
},
{ "siglongjmp",
  "#line 1 \"<builtin-library>-siglongjmp\"\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#include <setjmp.h>\n"
  "#define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline void siglongjmp(sigjmp_buf env, int val)\n"
  "{\n"
  "  // does not return\n"
  "  (void)env;\n"
  "  (void)val;\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "\n"
},
{ "setjmp",
  "#line 1 \"<builtin-library>-setjmp\"\n"
  "\n"
  "#ifndef __CPROVER_SETJMP_H_INCLUDED\n"
  "#include <setjmp.h>\n"
  "#define __CPROVER_SETJMP_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int setjmp(jmp_buf env)\n"
  "{\n"
  "  // store PC\n"
  "  int retval;\n"
  "  (void)env;\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "kill",
  "#line 1 \"<builtin-library>-kill\"\n"
  "\n"
  "#ifndef __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#include <sys/types.h>\n"
  "#define __CPROVER_SYS_TYPES_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_SIGNAL_H_INCLUDED\n"
  "#include <signal.h>\n"
  "#define __CPROVER_SIGNAL_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int kill(pid_t pid, int sig)\n"
  "{\n"
  "  (void)pid;\n"
  "  (void)sig;\n"
  "  __CPROVER_bool error;\n"
  "  return error ? -1 : 0;\n"
  "}\n"
  "\n"
},
{ "putchar",
  "#line 1 \"<builtin-library>-putchar\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int putchar(int c)\n"
  "{\n"
  "  __CPROVER_bool error;\n"
  "  __CPROVER_HIDE: printf(\"%c\", c);\n"
  "  return (error?-1:c);\n"
  "}\n"
  "\n"
},
{ "puts",
  "#line 1 \"<builtin-library>-puts\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int puts(const char *s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_bool error;\n"
  "  int ret;\n"
  "  printf(\"%s\\n\", s);\n"
  "  if(error) ret=-1; else __CPROVER_assume(ret>=0);\n"
  "  return ret;\n"
  "}\n"
  "\n"
},
{ "fopen",
  "#line 1 \"<builtin-library>-fopen\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline FILE *fopen(const char *filename, const char *mode)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*filename;\n"
  "  (void)*mode;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(filename), \"fopen zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(mode), \"fopen zero-termination of 2nd argument\");\n"
  "  #endif\n"
  "\n"
  "  FILE *f=malloc(sizeof(FILE));\n"
  "\n"
  "  return f;\n"
  "}\n"
  "\n"
},
{ "fclose",
  "#line 1 \"<builtin-library>-fclose\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fclose(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  free(stream);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fdopen",
  "#line 1 \"<builtin-library>-fdopen\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline FILE *fdopen(int handle, const char *mode)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)handle;\n"
  "  (void)*mode;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(mode),\n"
  "    \"fdopen zero-termination of 2nd argument\");\n"
  "  #endif\n"
  "\n"
  "  FILE *f=malloc(sizeof(FILE));\n"
  "\n"
  "  return f;\n"
  "}\n"
  "\n"
},
{ "fgets",
  "#line 1 \"<builtin-library>-fgets\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline char *fgets(char *str, int size, FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_bool error;\n"
  "\n"
  "  (void)size;\n"
  "  (void)*stream;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  int resulting_size;\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(str)>=size, \"buffer-overflow in fgets\");\n"
  "  if(size>0)\n"
  "  {\n"
  "    __CPROVER_assume(resulting_size<size);\n"
  "    __CPROVER_is_zero_string(str)=!error;\n"
  "    __CPROVER_zero_string_length(str)=resulting_size;\n"
  "  }\n"
  "  #endif\n"
  "\n"
  "  return error?0:str;\n"
  "}\n"
  "\n"
},
{ "fread",
  "#line 1 \"<builtin-library>-fread\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline size_t fread(\n"
  "  void *ptr,\n"
  "  size_t size,\n"
  "  size_t nitems,\n"
  "  FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  size_t nread;\n"
  "  size_t bytes=nread*size;\n"
  "  size_t i;\n"
  "  __CPROVER_assume(nread<=nitems);\n"
  "\n"
  "  (void)*stream;\n"
  "\n"
  "  for(i=0; i<bytes; i++)\n"
  "  {\n"
  "    char nondet_char;\n"
  "    ((char *)ptr)[i]=nondet_char;\n"
  "  }\n"
  "\n"
  "  return nread;\n"
  "}\n"
  "\n"
},
{ "feof",
  "#line 1 \"<builtin-library>-feof\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int feof(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "ferror",
  "#line 1 \"<builtin-library>-ferror\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int ferror(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fileno",
  "#line 1 \"<builtin-library>-fileno\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fileno(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fputs",
  "#line 1 \"<builtin-library>-fputs\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fputs(const char *s, FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s), \"fputs zero-termination of 1st argument\");\n"
  "  #endif\n"
  "  (void)*s;\n"
  "  (void)*stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fflush",
  "#line 1 \"<builtin-library>-fflush\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fflush(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fpurge",
  "#line 1 \"<builtin-library>-fpurge\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fpurge(FILE *stream)\n"
  "{\n"
  "  // just return nondet\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fgetc",
  "#line 1 \"<builtin-library>-fgetc\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fgetc(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  // it's a byte or EOF (-1)\n"
  "  __CPROVER_assume(return_value>=-1 && return_value<=255);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "getc",
  "#line 1 \"<builtin-library>-getc\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int getc(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  // it's a byte or EOF\n"
  "  __CPROVER_assume(return_value>=-1 && return_value<=255);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "getchar",
  "#line 1 \"<builtin-library>-getchar\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int getchar()\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  // it's a byte or EOF\n"
  "  __CPROVER_assume(return_value>=-1 && return_value<=255);\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "getw",
  "#line 1 \"<builtin-library>-getw\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int getw(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  // it's any int, no restriction\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "fseek",
  "#line 1 \"<builtin-library>-fseek\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fseek(FILE *stream, long offset, int whence)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  (void)offset;\n"
  "  (void)whence;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "ftell",
  "#line 1 \"<builtin-library>-ftell\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline long ftell(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int return_value;\n"
  "  (void)*stream;\n"
  "  return return_value;\n"
  "}\n"
  "\n"
},
{ "rewind",
  "#line 1 \"<builtin-library>-rewind\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void rewind(FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:\n"
  "  (void)*stream;\n"
  "}\n"
  "\n"
},
{ "fwrite",
  "#line 1 \"<builtin-library>-fwrite\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "size_t fwrite(\n"
  "  const void *ptr,\n"
  "  size_t size,\n"
  "  size_t nitems,\n"
  "  FILE *stream)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*(char*)ptr;\n"
  "  (void)size;\n"
  "  (void)*stream;\n"
  "  size_t nwrite;\n"
  "  __CPROVER_assume(nwrite<=nitems);\n"
  "  return nwrite;\n"
  "}\n"
  "\n"
},
{ "perror",
  "#line 1 \"<builtin-library>-perror\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void perror(const char *s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if(s!=0)\n"
  "  {\n"
  "    #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "    __CPROVER_assert(__CPROVER_is_zero_string(s), \"perror zero-termination\");\n"
  "    #endif\n"
  "    // should go to stderr\n"
  "    if(s[0]!=0)\n"
  "      printf(\"%s: \", s);\n"
  "  }\n"
  "  \n"
  "  // TODO: print errno error\n"
  "}\n"
  "\n"
},
{ "fscanf",
  "#line 1 \"<builtin-library>-fscanf\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fscanf(FILE *restrict stream, const char *restrict format, ...)\n"
  "{\n"
  "  __CPOVER_HIDE:;\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  int result=vfscanf(stream, format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "scanf",
  "#line 1 \"<builtin-library>-scanf\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int scanf(const char *restrict format, ...)\n"
  "{\n"
  "  __CPOVER_HIDE:;\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  int result=vfscanf(stdin, format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "sscanf",
  "#line 1 \"<builtin-library>-sscanf\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int sscanf(const char *restrict s, const char *restrict format, ...)\n"
  "{\n"
  "  __CPOVER_HIDE:;\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  int result=vsscanf(s, format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "vfscanf",
  "#line 1 \"<builtin-library>-vfscanf\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int vfscanf(FILE *restrict stream, const char *restrict format, va_list arg)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int result;\n"
  "  (void)*stream;\n"
  "  (void)*format;\n"
  "  (void)arg;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "vscanf",
  "#line 1 \"<builtin-library>-vscanf\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int vscanf(const char *restrict format, va_list arg)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return vfscanf(stdin, format, arg);\n"
  "}\n"
  "\n"
},
{ "vsscanf",
  "#line 1 \"<builtin-library>-vsscanf\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int vsscanf(const char *restrict s, const char *restrict format, va_list arg)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int result;\n"
  "  (void)*s;\n"
  "  (void)*format;\n"
  "  (void)arg;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "fprintf",
  "#line 1 \"<builtin-library>-fprintf\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int fprintf(FILE *stream, const char *restrict format, ...)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  va_list list;\n"
  "  va_start(list, format);\n"
  "  int result=vfprintf(stream, format, list);\n"
  "  va_end(list);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "vfprintf",
  "#line 1 \"<builtin-library>-vfprintf\"\n"
  "\n"
  "#ifndef __CPROVER_STDIO_H_INCLUDED\n"
  "#include <stdio.h>\n"
  "#define __CPROVER_STDIO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDARG_H_INCLUDED\n"
  "#include <stdarg.h>\n"
  "#define __CPROVER_STDARG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline int vfprintf(FILE *stream, const char *restrict format, va_list arg)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int result;\n"
  "  (void)*stream;\n"
  "  (void)*format;\n"
  "  (void)arg;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "abs",
  "#line 1 \"<builtin-library>-abs\"\n"
  "\n"
  "#undef abs\n"
  "\n"
  "inline int abs(int i) { return __CPROVER_abs(i); }\n"
  "\n"
},
{ "labs",
  "#line 1 \"<builtin-library>-labs\"\n"
  "\n"
  "#undef labs\n"
  "\n"
  "inline long int labs(long int i) { return __CPROVER_labs(i); }\n"
  "\n"
},
{ "exit",
  "#line 1 \"<builtin-library>-exit\"\n"
  "\n"
  "#undef exit\n"
  "\n"
  "inline void exit(int status)\n"
  "{\n"
  "  (void)status;\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "\n"
},
{ "_Exit",
  "#line 1 \"<builtin-library>-_Exit\"\n"
  "\n"
  "#undef _Exit\n"
  "\n"
  "inline void _Exit(int status)\n"
  "{\n"
  "  (void)status;\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "\n"
},
{ "abort",
  "#line 1 \"<builtin-library>-abort\"\n"
  "\n"
  "#undef abort\n"
  "\n"
  "inline void abort(void)\n"
  "{\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "\n"
},
{ "calloc",
  "#line 1 \"<builtin-library>-calloc\"\n"
  "\n"
  "#undef calloc\n"
  "#undef malloc\n"
  "\n"
  "inline void *malloc(__CPROVER_size_t malloc_size);\n"
  "\n"
  "inline void *calloc(__CPROVER_size_t nmemb, __CPROVER_size_t size)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_size_t total_size=nmemb*size;\n"
  "  void *res;\n"
  "  res=malloc(total_size);\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_is_zero_string(res)=1;\n"
  "  __CPROVER_zero_string_length(res)=0;\n"
  "  //for(int i=0; i<nmemb*size; i++) res[i]=0;\n"
  "  #else\n"
  "  // there should be memset here\n"
  "  //char *p=res;\n"
  "  //for(int i=0; i<total_size; i++) p[i]=0;\n"
  "  #endif\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "malloc",
  "#line 1 \"<builtin-library>-malloc\"\n"
  "\n"
  "#undef malloc\n"
  "\n"
  "inline void *malloc(__CPROVER_size_t malloc_size)\n"
  "{\n"
  "  // realistically, malloc may return NULL,\n"
  "  // and __CPROVER_malloc doesn't, but no one cares\n"
  "  __CPROVER_HIDE:;\n"
  "  void *res;\n"
  "  res=__CPROVER_malloc(malloc_size);\n"
  "\n"
  "  // make sure it's not recorded as deallocated\n"
  "  __CPROVER_deallocated=(res==__CPROVER_deallocated)?0:__CPROVER_deallocated;\n"
  "  \n"
  "  // record the object size for non-determistic bounds checking\n"
  "  __CPROVER_bool record_malloc;\n"
  "  __CPROVER_malloc_object=record_malloc?res:__CPROVER_malloc_object;\n"
  "  __CPROVER_malloc_size=record_malloc?malloc_size:__CPROVER_malloc_size;\n"
  "  __CPROVER_malloc_is_new_array=record_malloc?0:__CPROVER_malloc_is_new_array;\n"
  "  \n"
  "  // detect memory leaks\n"
  "  __CPROVER_bool record_may_leak;\n"
  "  __CPROVER_memory_leak=record_may_leak?res:__CPROVER_memory_leak;\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "__builtin_alloca",
  "#line 1 \"<builtin-library>-__builtin_alloca\"\n"
  "\n"
  "inline void *__builtin_alloca(__CPROVER_size_t alloca_size)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  void *res;\n"
  "  res=__CPROVER_malloc(alloca_size);\n"
  "\n"
  "  // make sure it's not recorded as deallocated\n"
  "  __CPROVER_deallocated=(res==__CPROVER_deallocated)?0:__CPROVER_deallocated;\n"
  "  \n"
  "  // record the object size for non-determistic bounds checking\n"
  "  __CPROVER_bool record_malloc;\n"
  "  __CPROVER_malloc_object=record_malloc?res:__CPROVER_malloc_object;\n"
  "  __CPROVER_malloc_size=record_malloc?alloca_size:__CPROVER_malloc_size;\n"
  "  __CPROVER_malloc_is_new_array=record_malloc?0:__CPROVER_malloc_is_new_array;\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "free",
  "#line 1 \"<builtin-library>-free\"\n"
  "\n"
  "#undef free\n"
  "\n"
  "inline void free(void *ptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // If ptr is NULL, no operation is performed.\n"
  "  if(ptr!=0)\n"
  "  {\n"
  "    // is it dynamic?\n"
  "    __CPROVER_assert(__CPROVER_DYNAMIC_OBJECT(ptr),\n"
  "                     \"free argument is dynamic object\");\n"
  "    __CPROVER_assert(__CPROVER_POINTER_OFFSET(ptr)==0,\n"
  "                     \"free argument has offset zero\");\n"
  "\n"
  "    // catch double free\n"
  "    if(__CPROVER_deallocated==ptr)\n"
  "      __CPROVER_assert(0, \"double free\");\n"
  "      \n"
  "    // catch people who try to use free(...) for stuff\n"
  "    // allocated with new[]\n"
  "    __CPROVER_assert(__CPROVER_malloc_object!=ptr ||\n"
  "                     !__CPROVER_malloc_is_new_array,\n"
  "                     \"free called for new[] object\");\n"
  "    \n"
  "    // non-deterministically record as deallocated\n"
  "    __CPROVER_bool record;\n"
  "    if(record) __CPROVER_deallocated=ptr;\n"
  "\n"
  "    // detect memory leaks\n"
  "    if(__CPROVER_memory_leak==ptr) __CPROVER_memory_leak=0;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "strtol",
  "#line 1 \"<builtin-library>-strtol\"\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_LIMITS_H_INCLUDED\n"
  "#include <limits.h>\n"
  "#define __CPROVER_LIMITS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strtol\n"
  "#undef isdigit\n"
  "#undef isspace\n"
  "\n"
  "int isspace(int);\n"
  "int isdigit(int);\n"
  "\n"
  "inline long strtol(const char *nptr, char **endptr, int base)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(nptr),\n"
  "    \"zero-termination of argument of strtol\");\n"
  "  #endif\n"
  "\n"
  "  if(base==1 || base<0 || base>36)\n"
  "  {\n"
  "    errno=EINVAL;\n"
  "    return 0;\n"
  "  }\n"
  "\n"
  "  long res=0;\n"
  "  _Bool in_number=0;\n"
  "  char sign=0;\n"
  "\n"
  "  // 32 chars is an arbitrarily chosen limit\n"
  "  int i=0;\n"
  "  for( ; i<31; ++i)\n"
  "  {\n"
  "    char ch=nptr[i];\n"
  "    char sub=0;\n"
  "    if(ch==0)\n"
  "      break;\n"
  "    else if((base==0 || base==16) && !in_number &&\n"
  "            ch=='0' && (nptr[i+1]=='x' || nptr[i+1]=='X'))\n"
  "    {\n"
  "      base=16;\n"
  "      in_number=1;\n"
  "      ++i;\n"
  "      continue;\n"
  "    }\n"
  "    else if(base==0 && !in_number && ch=='0')\n"
  "    {\n"
  "      base=8;\n"
  "      in_number=1;\n"
  "      continue;\n"
  "    }\n"
  "    else if(!in_number && !sign && isspace(ch))\n"
  "      continue;\n"
  "    else if(!in_number && !sign && (ch=='-' || ch=='+'))\n"
  "    {\n"
  "      sign=ch;\n"
  "      continue;\n"
  "    }\n"
  "    else if(base>10 && ch>='a' && ch-'a'<base-10)\n"
  "      sub='a'-10;\n"
  "    else if(base>10 && ch>='A' && ch-'A'<base-10)\n"
  "      sub='A'-10;\n"
  "    else if(isdigit(ch))\n"
  "    {\n"
  "      sub='0';\n"
  "      base=base==0 ? 10 : base;\n"
  "    }\n"
  "    else\n"
  "      break;\n"
  "\n"
  "    in_number=1;\n"
  "    long res_before=res;\n"
  "    res=res*base+ch-sub;\n"
  "    if(res<res_before)\n"
  "    {\n"
  "      errno=ERANGE;\n"
  "      if(sign=='-')\n"
  "        return LONG_MIN;\n"
  "      else\n"
  "        return LONG_MAX;\n"
  "    }\n"
  "  }\n"
  "\n"
  "  if(endptr!=0)\n"
  "    *endptr=(char*)nptr+i;\n"
  "\n"
  "  if(sign=='-')\n"
  "    res*=-1;\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "atoi",
  "#line 1 \"<builtin-library>-atoi\"\n"
  "\n"
  "#undef atoi\n"
  "#undef strtol\n"
  "\n"
  "long strtol(const char *nptr, char **endptr, int base);\n"
  "\n"
  "inline int atoi(const char *nptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return (int)strtol(nptr, (char **)0, 10);\n"
  "}\n"
  "\n"
},
{ "atol",
  "#line 1 \"<builtin-library>-atol\"\n"
  "\n"
  "#undef atol\n"
  "#undef strtol\n"
  "\n"
  "long strtol(const char *nptr, char **endptr, int base);\n"
  "\n"
  "inline long atol(const char *nptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  return strtol(nptr, (char **)0, 10);\n"
  "}\n"
  "\n"
},
{ "getenv",
  "#line 1 \"<builtin-library>-getenv\"\n"
  "\n"
  "#undef getenv\n"
  "\n"
  "inline char *getenv(const char *name)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  (void)*name;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(name),\n"
  "    \"zero-termination of argument of getenv\");\n"
  "  #endif\n"
  "\n"
  "  __CPROVER_bool found;\n"
  "  if(!found) return 0;\n"
  "\n"
  "  char *buffer;\n"
  "  __CPROVER_size_t buf_size;\n"
  "\n"
  "  __CPROVER_assume(buf_size>=1);\n"
  "  buffer=(char *)__CPROVER_malloc(buf_size);\n"
  "  buffer[buf_size-1]=0;\n"
  "\n"
  "  return buffer;\n"
  "}\n"
  "\n"
},
{ "realloc",
  "#line 1 \"<builtin-library>-realloc\"\n"
  "\n"
  "inline void *malloc(__CPROVER_size_t malloc_size);\n"
  "inline void free(void *ptr);\n"
  "\n"
  "inline void *realloc(void *ptr, __CPROVER_size_t malloc_size)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "\n"
  "  // if ptr is NULL, this behaves like malloc\n"
  "  if(ptr==0)\n"
  "    return malloc(malloc_size);\n"
  "\n"
  "  // if malloc-size is 0, allocate new minimum sized object\n"
  "  // and free original\n"
  "  if(malloc_size==0)\n"
  "  {\n"
  "    free(ptr);\n"
  "    return malloc(1);\n"
  "  }\n"
  "\n"
  "  __CPROVER_assert(__CPROVER_DYNAMIC_OBJECT(ptr),\n"
  "                   \"realloc argument is dynamic object\");\n"
  "\n"
  "  // this shouldn't move if the new size isn't bigger\n"
  "  void *res;\n"
  "  res=malloc(malloc_size);\n"
  "  __CPROVER_array_copy(res, ptr);\n"
  "  free(ptr);\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "valloc",
  "#line 1 \"<builtin-library>-valloc\"\n"
  "\n"
  "inline void *malloc(__CPROVER_size_t malloc_size);\n"
  "\n"
  "inline void *valloc(__CPROVER_size_t malloc_size)\n"
  "{\n"
  "  // The allocated memory is aligned on a page\n"
  "  // boundary, which we don't model.\n"
  "     \n"
  "  __CPROVER_HIDE:;\n"
  "  return malloc(malloc_size);\n"
  "}\n"
  "\n"
},
{ "random",
  "#line 1 \"<builtin-library>-random\"\n"
  "\n"
  "long random(void)\n"
  "{\n"
  "  // We return a non-deterministic value instead of a random one.\n"
  "  __CPROVER_HIDE:;\n"
  "  long result;\n"
  "  __CPROVER_assume(result>=0 && result<=2147483647);\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "__builtin___strcpy_chk",
  "#line 1 \"<builtin-library>-__builtin___strcpy_chk\"\n"
  "\n"
  "inline char *__builtin___strcpy_chk(char *dst, const char *src, __CPROVER_size_t s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src), \"strcpy zero-termination of 2nd argument\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>__CPROVER_zero_string_length(src), \"strcpy buffer overflow\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)==s, \"builtin object size\");\n"
  "  dst[__CPROVER_zero_string_length(src)]=0;\n"
  "  __CPROVER_is_zero_string(dst)=1;\n"
  "  __CPROVER_zero_string_length(dst)=__CPROVER_zero_string_length(src);\n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  char ch;\n"
  "  do\n"
  "  {\n"
  "    ch=src[i];\n"
  "    dst[i]=ch;\n"
  "    i++;\n"
  "  }\n"
  "  while(i<s && ch!=(char)0);\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "__builtin___strcat_chk",
  "#line 1 \"<builtin-library>-__builtin___strcat_chk\"\n"
  "\n"
  "__inline char *__builtin___strcat_chk(char *dst, const char *src, __CPROVER_size_t s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_size_t new_size;\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(dst), \"strcat zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src), \"strcat zero-termination of 2nd argument\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)==s, \"builtin object size\");\n"
  "  new_size=__CPROVER_zero_string_length(dst)+__CPROVER_zero_string_length(src);\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>new_size,\n"
  "                   \"strcat buffer overflow\");\n"
  "  __CPROVER_size_t old_size=__CPROVER_zero_string_length(dst);\n"
  "  //\"  for(size_t i=0; i<__CPROVER_zero_string_length(src); i++)\n"
  "  //\"    dst[old_size+i];\n"
  "  dst[new_size]=0;\n"
  "  __CPROVER_is_zero_string(dst)=1;\n"
  "  __CPROVER_zero_string_length(dst)=new_size;\n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  while(dst[i]!=0) i++;\n"
  "\n"
  "  __CPROVER_size_t j=0;\n"
  "  char ch;\n"
  "  do\n"
  "  {\n"
  "    char ch=src[j];\n"
  "    dst[i]=ch;\n"
  "    i++;\n"
  "    j++;\n"
  "  }\n"
  "  while(i<s && ch!=(char)0);\n"
  "  #endif\n"
  "  return dst;\n"
  "}                        \n"
  "\n"
},
{ "__builtin___strncat_chk",
  "#line 1 \"<builtin-library>-__builtin___strncat_chk\"\n"
  "\n"
  "__inline char *__builtin___strncat_chk(\n"
  "  char *dst, const char *src, __CPROVER_size_t n, __CPROVER_size_t s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_size_t additional, new_size;\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(dst), \"strncat zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src) || __CPROVER_buffer_size(src)>=n, \"strncat zero-termination of 2nd argument\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)==s, \"builtin object size\");\n"
  "  additional=(n<__CPROVER_zero_string_length(src))?n:__CPROVER_zero_string_length(src);\n"
  "  new_size=__CPROVER_is_zero_string(dst)+additional; \n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>new_size,\n"
  "                   \"strncat buffer overflow\");\n"
  "  __CPROVER_size_t dest_len=__CPROVER_zero_string_length(dst); \n"
  "  __CPROVER_size_t i;\n"
  "  for (i = 0 ; i < n && i<__CPROVER_zero_string_length(src) ; i++)\n"
  "    dst[dest_len + i] = src[i];\n"
  "  dst[dest_len + i] = 0;\n"
  "  __CPROVER_is_zero_string(dst)=1;\n"
  "  __CPROVER_zero_string_length(dst)=new_size;\n"
  "  #else\n"
  "  (void)*dst;\n"
  "  (void)*src;\n"
  "  (void)n;\n"
  "  (void)s;\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strcpy",
  "#line 1 \"<builtin-library>-strcpy\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strcpy\n"
  "\n"
  "inline char *strcpy(char *dst, const char *src)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src), \"strcpy zero-termination of 2nd argument\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>__CPROVER_zero_string_length(src), \"strcpy buffer overflow\");\n"
  "  dst[__CPROVER_zero_string_length(src)]=0;\n"
  "  __CPROVER_is_zero_string(dst)=1;\n"
  "  __CPROVER_zero_string_length(dst)=__CPROVER_zero_string_length(src);\n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  char ch;\n"
  "  do\n"
  "  {\n"
  "    ch=src[i];\n"
  "    dst[i]=ch;\n"
  "    i++;\n"
  "  }\n"
  "  while(ch!=(char)0);\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strncpy",
  "#line 1 \"<builtin-library>-strncpy\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strncpy\n"
  "\n"
  "inline char *strncpy(char *dst, const char *src, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src), \"strncpy zero-termination of 2nd argument\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>=n, \"strncpy buffer overflow\");\n"
  "  __CPROVER_is_zero_string(dst)=__CPROVER_zero_string_length(src)<n;\n"
  "  __CPROVER_zero_string_length(dst)=__CPROVER_zero_string_length(src);  \n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  char ch;\n"
  "  _Bool end;\n"
  "\n"
  "  // We use a single loop to make bounds checking etc easier.\n"
  "  // Note that strncpy _always_ writes 'n' characters into 'dst'.\n"
  "  for(end=0; i<n; i++)\n"
  "  {\n"
  "    ch=end?0:src[i];\n"
  "    dst[i]=ch;\n"
  "    end=end || ch==(char)0;\n"
  "  }\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "__builtin___strncpy_chk",
  "#line 1 \"<builtin-library>-__builtin___strncpy_chk\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "inline char *__builtin___strncpy_chk(char *dst, const char *src, size_t n, size_t object_size)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src), \"strncpy zero-termination of 2nd argument\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>=n, \"strncpy buffer overflow\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)==object_size, \"builtin object size\");\n"
  "  __CPROVER_is_zero_string(dst)=__CPROVER_zero_string_length(src)<n;\n"
  "  __CPROVER_zero_string_length(dst)=__CPROVER_zero_string_length(src);  \n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  char ch;\n"
  "  _Bool end;\n"
  "  (void)object_size;\n"
  "\n"
  "  // We use a single loop to make bounds checking etc easier.\n"
  "  // Note that strncpy _always_ writes 'n' characters into 'dst'.\n"
  "  for(end=0; i<n; i++)\n"
  "  {\n"
  "    ch=end?0:src[i];\n"
  "    dst[i]=ch;\n"
  "    end=end || ch==(char)0;\n"
  "  }\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strcat",
  "#line 1 \"<builtin-library>-strcat\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strcat\n"
  "\n"
  "inline char *strcat(char *dst, const char *src)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_size_t new_size;\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(dst), \"strcat zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src), \"strcat zero-termination of 2nd argument\");\n"
  "  new_size=__CPROVER_zero_string_length(dst)+__CPROVER_zero_string_length(src);\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>new_size,\n"
  "                   \"strcat buffer overflow\");\n"
  "  __CPROVER_size_t old_size=__CPROVER_zero_string_length(dst);\n"
  "  //\"  for(size_t i=0; i<__CPROVER_zero_string_length(src); i++)\n"
  "  //\"    dst[old_size+i];\n"
  "  dst[new_size]=0;\n"
  "  __CPROVER_is_zero_string(dst)=1;\n"
  "  __CPROVER_zero_string_length(dst)=new_size;\n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  while(dst[i]!=0) i++;\n"
  "\n"
  "  __CPROVER_size_t j=0;\n"
  "  char ch;\n"
  "  do\n"
  "  {\n"
  "    char ch=src[j];\n"
  "    dst[i]=ch;\n"
  "    i++;\n"
  "    j++;\n"
  "  }\n"
  "  while(ch!=(char)0);\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strncat",
  "#line 1 \"<builtin-library>-strncat\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strncat\n"
  "\n"
  "inline char *strncat(char *dst, const char *src, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_size_t additional, new_size;\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(dst), \"strncat zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src) || __CPROVER_buffer_size(src)>=n, \"strncat zero-termination of 2nd argument\");\n"
  "  additional=(n<__CPROVER_zero_string_length(src))?n:__CPROVER_zero_string_length(src);\n"
  "  new_size=__CPROVER_is_zero_string(dst)+additional; \n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>new_size,\n"
  "                   \"strncat buffer overflow\");\n"
  "  __CPROVER_size_t dest_len=__CPROVER_zero_string_length(dst); \n"
  "  __CPROVER_size_t i;\n"
  "  for (i = 0 ; i < n && i<__CPROVER_zero_string_length(src) ; i++)\n"
  "    dst[dest_len + i] = src[i];\n"
  "  dst[dest_len + i] = 0;\n"
  "  __CPROVER_is_zero_string(dst)=1;\n"
  "  __CPROVER_zero_string_length(dst)=new_size;\n"
  "  #else\n"
  "  (void)*dst;\n"
  "  (void)*src;\n"
  "  (void)n;\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "strcmp",
  "#line 1 \"<builtin-library>-strcmp\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strcmp\n"
  "\n"
  "inline int strcmp(const char *s1, const char *s2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if(s1!=0 && s1==s2) return 0;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  int retval;\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s1), \"strcmp zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s2), \"strcmp zero-termination of 2nd argument\");\n"
  "  if(__CPROVER_zero_string_length(s1) != __CPROVER_zero_string_length(s2)) __CPROVER_assume(retval!=0);\n"
  "  return retval;\n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  unsigned char ch1, ch2;\n"
  "  do\n"
  "  {\n"
  "    ch1=s1[i];\n"
  "    ch2=s2[i];\n"
  "\n"
  "    if(ch1==ch2)\n"
  "    {\n"
  "    }\n"
  "    else if(ch1<ch2)\n"
  "      return -1;\n"
  "    else\n"
  "      return 1;\n"
  "\n"
  "    i++;\n"
  "  }\n"
  "  while(ch1!=0 && ch2!=0);\n"
  "  return 0;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "strcasecmp",
  "#line 1 \"<builtin-library>-strcasecmp\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strcasecmp\n"
  "\n"
  "inline int strcasecmp(const char *s1, const char *s2)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if(s1!=0 && s1==s2) return 0;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  int retval;\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s1), \"strcasecmp zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s2), \"strcasecmp zero-termination of 2nd argument\");\n"
  "  if(__CPROVER_zero_string_length(s1) != __CPROVER_zero_string_length(s2)) __CPROVER_assume(retval!=0);\n"
  "  return retval;\n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  unsigned char ch1, ch2;\n"
  "  do\n"
  "  {\n"
  "    ch1=s1[i];\n"
  "    ch2=s2[i];\n"
  "    \n"
  "    if(ch1>='A' && ch1<='Z') ch1+=('a'-'A');\n"
  "    if(ch2>='A' && ch2<='Z') ch2+=('a'-'A');\n"
  "\n"
  "    if(ch1==ch2)\n"
  "    {\n"
  "    }\n"
  "    else if(ch1<ch2)\n"
  "      return -1;\n"
  "    else\n"
  "      return 1;\n"
  "\n"
  "    i++;\n"
  "  }\n"
  "  while(ch1!=0 && ch2!=0);\n"
  "  return 0;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "strncmp",
  "#line 1 \"<builtin-library>-strncmp\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strncmp\n"
  "\n"
  "inline int strncmp(const char *s1, const char *s2, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if(s1!=0 && s1==s2) return 0;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s1) || __CPROVER_buffer_size(s1)>=n, \"strncmp zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s2) || __CPROVER_buffer_size(s2)>=n, \"strncmp zero-termination of 2nd argument\");\n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  unsigned char ch1, ch2;\n"
  "  do\n"
  "  {\n"
  "    ch1=s1[i];\n"
  "    ch2=s2[i];\n"
  "\n"
  "    if(ch1==ch2)\n"
  "    {\n"
  "    }\n"
  "    else if(ch1<ch2)\n"
  "      return -1;\n"
  "    else\n"
  "      return 1;\n"
  "\n"
  "    i++;\n"
  "  }\n"
  "  while(ch1!=0 && ch2!=0 && i<n);\n"
  "  return 0;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "strncasecmp",
  "#line 1 \"<builtin-library>-strncasecmp\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strncasecmp\n"
  "\n"
  "inline int strncasecmp(const char *s1, const char *s2, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if(s1!=0 && s1==s2) return 0;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  int retval;\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s1), \"strncasecmp zero-termination of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s2), \"strncasecmp zero-termination of 2nd argument\");\n"
  "  return retval;\n"
  "  #else\n"
  "  __CPROVER_size_t i=0;\n"
  "  unsigned char ch1, ch2;\n"
  "  do\n"
  "  {\n"
  "    ch1=s1[i];\n"
  "    ch2=s2[i];\n"
  "    \n"
  "    if(ch1>='A' && ch1<='Z') ch1+=('a'-'A');\n"
  "    if(ch2>='A' && ch2<='Z') ch2+=('a'-'A');\n"
  "\n"
  "    if(ch1==ch2)\n"
  "    {\n"
  "    }\n"
  "    else if(ch1<ch2)\n"
  "      return -1;\n"
  "    else\n"
  "      return 1;\n"
  "\n"
  "    i++;\n"
  "  }\n"
  "  while(ch1!=0 && ch2!=0 && i<n);\n"
  "  return 0;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "strlen",
  "#line 1 \"<builtin-library>-strlen\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strlen\n"
  "\n"
  "inline size_t strlen(const char *s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s), \"strlen zero-termination\");\n"
  "  return __CPROVER_zero_string_length(s);\n"
  "  #else\n"
  "  __CPROVER_size_t len=0;\n"
  "  while(s[len]!=0) len++;\n"
  "  return len;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "strdup",
  "#line 1 \"<builtin-library>-strdup\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#ifndef __CPROVER_STDLIB_H_INCLUDED\n"
  "#include <stdlib.h>\n"
  "#define __CPROVER_STDLIB_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strdup\n"
  "#undef strcpy\n"
  "\n"
  "inline char *strdup(const char *str)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __CPROVER_size_t bufsz;\n"
  "  bufsz=(strlen(str)+1);\n"
  "  char *cpy=(char *)malloc(bufsz*sizeof(char));\n"
  "  if(cpy==((void *)0)) return 0;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assume(__CPROVER_buffer_size(cpy)==bufsz);\n"
  "  #endif\n"
  "  strcpy(cpy, str);\n"
  "  return cpy;\n"
  "}\n"
  "\n"
},
{ "memcpy",
  "#line 1 \"<builtin-library>-memcpy\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef memcpy\n"
  "\n"
  "inline void *memcpy(void *dst, const void *src, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(src)>=n, \"memcpy buffer overflow\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>=n, \"memcpy buffer overflow\");\n"
  "  //  for(size_t i=0; i<n ; i++) dst[i]=src[i];\n"
  "  if(__CPROVER_is_zero_string(src) &&\n"
  "     n > __CPROVER_zero_string_length(src))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(dst)=1;\n"
  "    __CPROVER_zero_string_length(dst)=__CPROVER_zero_string_length(src);\n"
  "  }\n"
  "  else if(!(__CPROVER_is_zero_string(dst) &&\n"
  "            n <= __CPROVER_zero_string_length(dst)))\n"
  "    __CPROVER_is_zero_string(dst)=0;\n"
  "  #else\n"
  "  for(__CPROVER_size_t i=0; i<n ; i++) ((char *)dst)[i]=((const char *)src)[i];\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "__builtin___memcpy_chk",
  "#line 1 \"<builtin-library>-__builtin___memcpy_chk\"\n"
  "\n"
  "void *__builtin___memcpy_chk(void *dst, const void *src, __CPROVER_size_t n, __CPROVER_size_t size)\n"
  "{\n"
  "  __CPROVER_HIDE:\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(src)>=n, \"memcpy buffer overflow\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)>=n, \"memcpy buffer overflow\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(dst)==s, \"builtin object size\");\n"
  "  //  for(size_t i=0; i<n ; i++) dst[i]=src[i];\n"
  "  if(__CPROVER_is_zero_string(src) &&\n"
  "     n > __CPROVER_zero_string_length(src))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(dst)=1;\n"
  "    __CPROVER_zero_string_length(dst)=__CPROVER_zero_string_length(src);\n"
  "  }\n"
  "  else if(!(__CPROVER_is_zero_string(dst) &&\n"
  "            n <= __CPROVER_zero_string_length(dst)))\n"
  "    __CPROVER_is_zero_string(dst)=0;\n"
  "  #else\n"
  "  (void)size;\n"
  "  for(__CPROVER_size_t i=0; i<n ; i++) ((char *)dst)[i]=((const char *)src)[i];\n"
  "  #endif\n"
  "  return dst;\n"
  "}\n"
  "\n"
},
{ "memset",
  "#line 1 \"<builtin-library>-memset\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef memset\n"
  "\n"
  "inline void *memset(void *s, int c, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(s)>=n, \"memset buffer overflow\");\n"
  "  //  for(size_t i=0; i<n ; i++) s[i]=c;\n"
  "  if(__CPROVER_is_zero_string(s) &&\n"
  "     n > __CPROVER_zero_string_length(s))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "  }\n"
  "  else if(c==0)\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "    __CPROVER_zero_string_length(s)=0;\n"
  "  }\n"
  "  else\n"
  "    __CPROVER_is_zero_string(s)=0;\n"
  "  #else\n"
  "  char *sp=s;\n"
  "  for(__CPROVER_size_t i=0; i<n ; i++) sp[i]=c;\n"
  "  #endif\n"
  "  return s;\n"
  "}\n"
  "\n"
},
{ "__builtin___memset_chk",
  "#line 1 \"<builtin-library>-__builtin___memset_chk\"\n"
  "\n"
  "void *__builtin___memset_chk(void *s, int c, __CPROVER_size_t n, __CPROVER_size_t size)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(s)>=n, \"memset buffer overflow\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(s)==size, \"builtin object size\");\n"
  "  //  for(size_t i=0; i<n ; i++) s[i]=c;\n"
  "  if(__CPROVER_is_zero_string(s) &&\n"
  "     n > __CPROVER_zero_string_length(s))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "  }\n"
  "  else if(c==0)\n"
  "  {\n"
  "    __CPROVER_is_zero_string(s)=1;\n"
  "    __CPROVER_zero_string_length(s)=0;\n"
  "  }\n"
  "  else\n"
  "    __CPROVER_is_zero_string(s)=0;\n"
  "  #else\n"
  "  (void)size;\n"
  "  char *sp=s;\n"
  "  for(__CPROVER_size_t i=0; i<n ; i++) sp[i]=c;\n"
  "  #endif\n"
  "  return s;\n"
  "}\n"
  "\n"
},
{ "memmove",
  "#line 1 \"<builtin-library>-memmove\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef memmove\n"
  "\n"
  "inline void *memmove(void *dest, const void *src, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(src)>=n, \"memmove buffer overflow\");\n"
  "  // dst = src (with overlap allowed)\n"
  "  if(__CPROVER_is_zero_string(src) &&\n"
  "     n > __CPROVER_zero_string_length(src))\n"
  "  {\n"
  "    __CPROVER_is_zero_string(src)=1;\n"
  "    __CPROVER_zero_string_length(dest)=__CPROVER_zero_string_length(src);\n"
  "  }\n"
  "  else\n"
  "    __CPROVER_is_zero_string(dest)=0;\n"
  "  #else\n"
  "  if((const char *)dest>=(const char *)src+n)\n"
  "  {\n"
  "    for(__CPROVER_size_t i=0; i<n; i++) ((char *)dest)[i]=((const char *)src)[i];\n"
  "  }\n"
  "  else \n"
  "  {\n"
  "    for(__CPROVER_size_t i=n; i>0; i--) ((char *)dest)[i-1]=((const char *)src)[i-1];\n"
  "  }\n"
  "  #endif\n"
  "  return dest;\n"
  "}\n"
  "\n"
},
{ "memcmp",
  "#line 1 \"<builtin-library>-memcmp\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef memcmp\n"
  "\n"
  "inline int memcmp(const void *s1, const void *s2, size_t n)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  int res=0;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(s1)>=n, \"memcmp buffer overflow of 1st argument\");\n"
  "  __CPROVER_assert(__CPROVER_buffer_size(s2)>=n, \"memcmp buffer overflow of 2nd argument\");\n"
  "  #else\n"
  "  const unsigned char *sc1=s1, *sc2=s2;\n"
  "  for(; n!=0; n--)\n"
  "  {\n"
  "    res = (*sc1++) - (*sc2++);\n"
  "    if (res != 0)\n"
  "      return res;\n"
  "  }\n"
  "  #endif\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "strchr",
  "#line 1 \"<builtin-library>-strchr\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strchr\n"
  "\n"
  "inline char *strchr(const char *src, int c)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src), \"strchr zero-termination of string argument\");\n"
  "  __CPROVER_bool found;\n"
  "  __CPROVER_size_t i;\n"
  "  return found?src+i:0;\n"
  "  #else\n"
  "  for(__CPROVER_size_t i=0; src[i]!=0; i++)\n"
  "    if(src[i]==(char)c)\n"
  "      return ((char *)src)+i; // cast away const-ness\n"
  "\n"
  "  return 0;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "strrchr",
  "#line 1 \"<builtin-library>-strrchr\"\n"
  "\n"
  "#ifndef __CPROVER_STRING_H_INCLUDED\n"
  "#include <string.h>\n"
  "#define __CPROVER_STRING_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef strchr\n"
  "\n"
  "inline char *strrchr(const char *src, int c)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(src), \"strrchr zero-termination of string argument\");\n"
  "  __CPROVER_bool found;\n"
  "  __CPROVER_size_t i;\n"
  "  return found?((char *)src)+i:0;\n"
  "  #else\n"
  "  char *res=0;\n"
  "  for(__CPROVER_size_t i=0; src[i]!=0; i++)\n"
  "    if(src[i]==(char)c) res=((char *)src)+i;\n"
  "  return res;\n"
  "  #endif\n"
  "}\n"
  "\n"
},
{ "openlog",
  "#line 1 \"<builtin-library>-openlog\"\n"
  "\n"
  "#ifndef __CPROVER_SYSLOG_H_INCLUDED\n"
  "#include <syslog.h>\n"
  "#define __CPROVER_SYSLOG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void openlog(const char *ident, int option, int facility)\n"
  "{\n"
  "  (void)*ident;\n"
  "  (void)option;\n"
  "  (void)facility;\n"
  "}\n"
  "\n"
},
{ "closelog",
  "#line 1 \"<builtin-library>-closelog\"\n"
  "\n"
  "#ifndef __CPROVER_SYSLOG_H_INCLUDED\n"
  "#include <syslog.h>\n"
  "#define __CPROVER_SYSLOG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void closelog(void)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "syslog",
  "#line 1 \"<builtin-library>-syslog\"\n"
  "\n"
  "#ifndef __CPROVER_SYSLOG_H_INCLUDED\n"
  "#include <syslog.h>\n"
  "#define __CPROVER_SYSLOG_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void syslog(int priority, const char *format, ...)\n"
  "{\n"
  "  (void)priority;\n"
  "  (void)*format;\n"
  "}\n"
},
{ "thrd_create",
  "#line 1 \"<builtin-library>-thrd_create\"\n"
  "\n"
  "// following http://en.cppreference.com/w/c/thread\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int thrd_create(thrd_t *thr, thrd_start_t func, void *arg)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_equal",
  "#line 1 \"<builtin-library>-thrd_equal\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int thrd_equal( thrd_t lhs, thrd_t rhs )\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_current",
  "#line 1 \"<builtin-library>-thrd_current\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "thrd_t thrd_current()\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_sleep",
  "#line 1 \"<builtin-library>-thrd_sleep\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int thrd_sleep(const struct timespec* time_point,\n"
  "               struct timespec* remaining)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_yield",
  "#line 1 \"<builtin-library>-thrd_yield\"\n"
  "\n"
  "void thrd_yield()\n"
  "{\n"
  "}\n"
  "\n"
},
{ "thrd_exit",
  "#line 1 \"<builtin-library>-thrd_exit\"\n"
  "\n"
  "void thrd_exit(int res)\n"
  "{\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "\n"
},
{ "mtx_init",
  "#line 1 \"<builtin-library>-mtx_init\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_init( mtx_t* mutex, int type )\n"
  "{\n"
  "}\n"
  "\n"
},
{ "mtx_lock",
  "#line 1 \"<builtin-library>-mtx_lock\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_lock(mtx_t* mutex)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "mtx_timedlock",
  "#line 1 \"<builtin-library>-mtx_timedlock\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_timedlock(mtx_t *restrict mutex,\n"
  "                  const struct timespec *restrict time_point)\n"
  "{\n"
  "\n"
  "}\n"
  "\n"
},
{ "mtx_trylock",
  "#line 1 \"<builtin-library>-mtx_trylock\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_trylock(mtx_t *mutex)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "mtx_unlock",
  "#line 1 \"<builtin-library>-mtx_unlock\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int mtx_unlock(mtx_t *mutex)\n"
  "{\n"
  "\n"
  "}\n"
  "\n"
},
{ "mtx_destroy",
  "#line 1 \"<builtin-library>-mtx_destroy\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void mtx_destroy(mtx_t *mutex)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "call_once",
  "#line 1 \"<builtin-library>-call_once\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void call_once(once_flag* flag, void (*func)(void))\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_init",
  "#line 1 \"<builtin-library>-cnd_init\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_init(cnd_t* cond)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_signal",
  "#line 1 \"<builtin-library>-cnd_signal\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_signal(cnd_t *cond)\n"
  "{\n"
  "\n"
  "}\n"
  "\n"
},
{ "cnd_broadcast",
  "#line 1 \"<builtin-library>-cnd_broadcast\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_broadcast(cnd_t *cond)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_wait",
  "#line 1 \"<builtin-library>-cnd_wait\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_wait(cnd_t* cond, mtx_t* mutex)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_timedwait",
  "#line 1 \"<builtin-library>-cnd_timedwait\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "int cnd_timedwait(cnd_t* restrict cond, mtx_t* restrict mutex,\n"
  "                  const struct timespec* restrict time_point)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "cnd_destroy",
  "#line 1 \"<builtin-library>-cnd_destroy\"\n"
  "\n"
  "#ifndef __CPROVER_THREADS_H_INCLUDED\n"
  "#include <threads.h>\n"
  "#define __CPROVER_THREADS_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "void cnd_destroy(cnd_t* cond)\n"
  "{\n"
  "}\n"
  "\n"
},
{ "time",
  "#line 1 \"<builtin-library>-time\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef time\n"
  "\n"
  "time_t time(time_t *tloc)\n"
  "{\n"
  "  time_t res;\n"
  "  if(!tloc) *tloc=res;\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "gmtime",
  "#line 1 \"<builtin-library>-gmtime\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef gmtime\n"
  "\n"
  "struct tm *gmtime(const time_t *clock)\n"
  "{\n"
  "  // not very general, may be too restrictive\n"
  "  // need to set the fields to something meaningful\n"
  "  (void)*clock;\n"
  "  static struct tm return_value;\n"
  "  return &return_value;\n"
  "}\n"
  "\n"
},
{ "gmtime_r",
  "#line 1 \"<builtin-library>-gmtime_r\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef gmtime\n"
  "\n"
  "struct tm *gmtime_r(const time_t *clock, struct tm *result)\n"
  "{\n"
  "  // need to set the fields to something meaningful\n"
  "  (void)*clock;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "localtime",
  "#line 1 \"<builtin-library>-localtime\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef localtime\n"
  "\n"
  "struct tm *localtime(const time_t *clock)\n"
  "{\n"
  "  // not very general, may be too restrictive\n"
  "  // need to set the fields to something meaningful\n"
  "  (void)*clock;\n"
  "  static struct tm return_value;\n"
  "  return &return_value;\n"
  "}\n"
  "\n"
},
{ "localtime_r",
  "#line 1 \"<builtin-library>-localtime_r\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef localtime\n"
  "\n"
  "struct tm *localtime_r(const time_t *clock, struct tm *result)\n"
  "{\n"
  "  // need to set the fields to something meaningful\n"
  "  (void)*clock;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "mktime",
  "#line 1 \"<builtin-library>-mktime\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef mktime\n"
  "\n"
  "time_t mktime(struct tm *timeptr)\n"
  "{\n"
  "  (void)*timeptr;\n"
  "  time_t result;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "timegm",
  "#line 1 \"<builtin-library>-timegm\"\n"
  "\n"
  "#ifndef __CPROVER_TIME_H_INCLUDED\n"
  "#include <time.h>\n"
  "#define __CPROVER_TIME_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "#undef timegm\n"
  "\n"
  "time_t timegm(struct tm *timeptr)\n"
  "{\n"
  "  (void)*timeptr;\n"
  "  time_t result;\n"
  "  return result;\n"
  "}\n"
  "\n"
},
{ "sleep",
  "#line 1 \"<builtin-library>-sleep\"\n"
  "\n"
  "unsigned int sleep(unsigned int seconds)\n"
  "{\n"
  "  // do nothing, but return nondet value\n"
  "  unsigned remaining_time;\n"
  "  \n"
  "  if(remaining_time>seconds) remaining_time=seconds;\n"
  "  \n"
  "  return remaining_time;\n"
  "}\n"
  "\n"
},
{ "unlink",
  "#line 1 \"<builtin-library>-unlink\"\n"
  "\n"
  "int unlink(const char *s)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)*s;\n"
  "  #ifdef __CPROVER_STRING_ABSTRACTION\n"
  "  __CPROVER_assert(__CPROVER_is_zero_string(s), \"unlink zero-termination\");\n"
  "  #endif\n"
  "  int retval;\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "pipe",
  "#line 1 \"<builtin-library>-pipe\"\n"
  "\n"
  "#ifndef __CPROVER_ERRNO_H_INCLUDED\n"
  "#include <errno.h>\n"
  "#define __CPROVER_ERRNO_H_INCLUDED\n"
  "#endif\n"
  "\n"
  "extern struct __CPROVER_pipet __CPROVER_pipes[];\n"
  "// offset to make sure we don't collide with other fds\n"
  "extern const int __CPROVER_pipe_offset;\n"
  "extern unsigned __CPROVER_pipe_count;\n"
  "\n"
  "int pipe(int fildes[2])\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  char error;\n"
  "  if(error)\n"
  "  {\n"
  "    errno=error==1 ? EMFILE : ENFILE;\n"
  "    return -1;\n"
  "  }\n"
  "\n"
  "  __CPROVER_atomic_begin();\n"
  "  __CPROVER_assume(__CPROVER_pipe_offset%2==0);\n"
  "  __CPROVER_assume(__CPROVER_pipe_offset<=(int)(__CPROVER_pipe_offset+__CPROVER_pipe_count));\n"
  "  fildes[0]=__CPROVER_pipe_offset+__CPROVER_pipe_count;\n"
  "  fildes[1]=__CPROVER_pipe_offset+__CPROVER_pipe_count+1;\n"
  "  __CPROVER_pipes[__CPROVER_pipe_count].widowed=0;\n"
  "  __CPROVER_pipes[__CPROVER_pipe_count].next_avail=0;\n"
  "  __CPROVER_pipes[__CPROVER_pipe_count].next_unread=0;\n"
  "  __CPROVER_pipe_count+=2;\n"
  "  __CPROVER_atomic_end();\n"
  "\n"
  "  __CPROVER_assume(fildes[0]!=0 && fildes[0]!=1 && fildes[0]!=2);\n"
  "  __CPROVER_assume(fildes[1]!=0 && fildes[1]!=1 && fildes[1]!=2);\n"
  "\n"
  "  return 0;\n"
  "}\n"
  "\n"
},
{ "close",
  "#line 1 \"<builtin-library>-close\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <io.h>\n"
  "#else\n"
  "#ifndef __CPROVER_UNISTD_H_INCLUDED\n"
  "#include <unistd.h>\n"
  "#define __CPROVER_UNISTD_H_INCLUDED\n"
  "#endif\n"
  "#endif\n"
  "\n"
  "extern struct __CPROVER_pipet __CPROVER_pipes[];\n"
  "// offset to make sure we don't collide with other fds\n"
  "extern const int __CPROVER_pipe_offset;\n"
  "\n"
  "int close(int fildes)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if((fildes>=0 && fildes<=2) || fildes < __CPROVER_pipe_offset)\n"
  "    return 0;\n"
  "\n"
  "  int retval=-1;\n"
  "  fildes-=__CPROVER_pipe_offset;\n"
  "  if(fildes%2==1)\n"
  "    --fildes;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(!__CPROVER_pipes[fildes].widowed)\n"
  "  {\n"
  "    __CPROVER_pipes[fildes].widowed=1;\n"
  "    __CPROVER_pipes[fildes].next_avail=__CPROVER_pipes[fildes].next_unread=0;\n"
  "    retval=0;\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "write",
  "#line 1 \"<builtin-library>-write\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <io.h>\n"
  "#else\n"
  "#ifndef __CPROVER_UNISTD_H_INCLUDED\n"
  "#include <unistd.h>\n"
  "#define __CPROVER_UNISTD_H_INCLUDED\n"
  "#endif\n"
  "#endif\n"
  "\n"
  "extern struct __CPROVER_pipet __CPROVER_pipes[];\n"
  "// offset to make sure we don't collide with other fds\n"
  "extern const int __CPROVER_pipe_offset;\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#define ssize_t signed long\n"
  "#endif\n"
  "\n"
  "ssize_t write(int fildes, const void *buf, size_t nbyte)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if((fildes>=0 && fildes<=2) || fildes < __CPROVER_pipe_offset)\n"
  "  {\n"
  "    ssize_t retval;\n"
  "    __CPROVER_assume(retval>=-1 && retval<=(ssize_t)nbyte);\n"
  "    return retval;\n"
  "  }\n"
  "\n"
  "  int retval=-1;\n"
  "  fildes-=__CPROVER_pipe_offset;\n"
  "  if(fildes%2==1)\n"
  "    --fildes;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(!__CPROVER_pipes[fildes].widowed &&\n"
  "      sizeof(__CPROVER_pipes[fildes].data) >=\n"
  "      __CPROVER_pipes[fildes].next_avail+nbyte)\n"
  "  {\n"
  "    for(size_t i=0; i<nbyte; ++i)\n"
  "      __CPROVER_pipes[fildes].data[i+__CPROVER_pipes[fildes].next_avail]=\n"
  "        ((char*)buf)[i];\n"
  "    __CPROVER_pipes[fildes].next_avail+=nbyte;\n"
  "    retval=nbyte;\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "read",
  "#line 1 \"<builtin-library>-read\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <io.h>\n"
  "#else\n"
  "#ifndef __CPROVER_UNISTD_H_INCLUDED\n"
  "#include <unistd.h>\n"
  "#define __CPROVER_UNISTD_H_INCLUDED\n"
  "#endif\n"
  "#endif\n"
  "\n"
  "extern struct __CPROVER_pipet __CPROVER_pipes[];\n"
  "// offset to make sure we don't collide with other fds\n"
  "extern const int __CPROVER_pipe_offset;\n"
  "\n"
  "#ifdef _MSC_VER\n"
  "#define ssize_t signed long\n"
  "#endif\n"
  "\n"
  "ssize_t read(int fildes, void *buf, size_t nbyte)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  if((fildes>=0 && fildes<=2) || fildes < __CPROVER_pipe_offset)\n"
  "  {\n"
  "    ssize_t nread;\n"
  "    size_t i;\n"
  "    __CPROVER_assume((size_t)nread<=nbyte);\n"
  "\n"
  "    for(i=0; i<nbyte; i++)\n"
  "    {\n"
  "      char nondet_char;\n"
  "      ((char *)buf)[i]=nondet_char;\n"
  "    }\n"
  "\n"
  "    __CPROVER_bool error;\n"
  "    return error ? -1 : nread;\n"
  "  }\n"
  "\n"
  "  int retval=0;\n"
  "  fildes-=__CPROVER_pipe_offset;\n"
  "  if(fildes%2==1)\n"
  "    --fildes;\n"
  "  __CPROVER_atomic_begin();\n"
  "  if(!__CPROVER_pipes[fildes].widowed)\n"
  "  {\n"
  "    for(size_t i=0; i<nbyte &&\n"
  "      __CPROVER_pipes[fildes].next_unread <\n"
  "      __CPROVER_pipes[fildes].next_avail;\n"
  "      ++i)\n"
  "    {\n"
  "      ((char*)buf)[i]=__CPROVER_pipes[fildes].\n"
  "        data[__CPROVER_pipes[fildes].next_unread];\n"
  "      ++__CPROVER_pipes[fildes].next_unread;\n"
  "      ++retval;\n"
  "    }\n"
  "    if(__CPROVER_pipes[fildes].next_avail==\n"
  "        __CPROVER_pipes[fildes].next_unread)\n"
  "      __CPROVER_pipes[fildes].next_avail=__CPROVER_pipes[fildes].next_unread=0;\n"
  "  }\n"
  "  __CPROVER_atomic_end();\n"
  "  return retval;\n"
  "}\n"
  "\n"
},
{ "QueryPerformanceFrequency",
  "#line 1 \"<builtin-library>-QueryPerformanceFrequency\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <windows.h>\n"
  "\n"
  "BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  __int64 result;\n"
  "  lpFrequency->QuadPart=result;\n"
  "  __CPROVER_bool error;\n"
  "  if(error) return 0;\n"
  "  __CPROVER_assume(result!=0);\n"
  "  return 1;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "ExitThread",
  "#line 1 \"<builtin-library>-ExitThread\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <windows.h>\n"
  "\n"
  "inline VOID ExitThread(DWORD dwExitCode)\n"
  "{\n"
  "  // never returns\n"
  "  __CPROVER_assume(0);\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "CreateThread",
  "#line 1 \"<builtin-library>-CreateThread\"\n"
  "\n"
  "#ifdef _WIN32\n"
  "#include <windows.h>\n"
  "\n"
  "inline HANDLE CreateThread(\n"
  "  LPSECURITY_ATTRIBUTES lpThreadAttributes,\n"
  "  SIZE_T dwStackSize,\n"
  "  LPTHREAD_START_ROUTINE lpStartAddress,\n"
  "  LPVOID lpParameter,\n"
  "  DWORD dwCreationFlags,\n"
  "  LPDWORD lpThreadId\n"
  ")\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  DWORD thread_id;\n"
  "\n"
  "  if(lpThreadId) *lpThreadId=thread_id;\n"
  "  __CPROVER_ASYNC_1: lpStartAddress(lpParameter);\n"
  "  \n"
  "  HANDLE handle;\n"
  "  return handle;\n"
  "}\n"
  "#endif\n"
  "\n"
},
{ "__asm_fnstcw",
  "#line 1 \"<builtin-library>-__asm_fnstcw\"\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "inline void __asm_fnstcw(unsigned short *dest)\n"
  "{\n"
  "  // the rounding mode is bits 10 and 11 in the control word\n"
  "  *dest=__CPROVER_rounding_mode<<10;\n"
  "}\n"
  "\n"
},
{ "__asm_fstcw",
  "#line 1 \"<builtin-library>-__asm_fstcw\"\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "inline void __asm_fstcw(unsigned short *dest)\n"
  "{\n"
  "  // the rounding mode is bits 10 and 11 in the control word\n"
  "  *dest=__CPROVER_rounding_mode<<10;\n"
  "}\n"
  "\n"
},
{ "__asm_fldcw",
  "#line 1 \"<builtin-library>-__asm_fldcw\"\n"
  "\n"
  "extern int __CPROVER_rounding_mode;\n"
  "\n"
  "inline void __asm_fldcw(const unsigned short *src)\n"
  "{\n"
  "  // the rounding mode is bits 10 and 11 in the control word\n"
  "  __CPROVER_rounding_mode=((*src)>>10)&3;\n"
  "}\n"
  "\n"
},
{ "__asm_mfence",
  "#line 1 \"<builtin-library>-__asm_mfence\"\n"
  "\n"
  "inline void __asm_mfence(void)\n"
  "{\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
  "\n"
},
{ "__asm_sfence",
  "#line 1 \"<builtin-library>-__asm_sfence\"\n"
  "\n"
  "inline void __asm_sfence(void)\n"
  "{\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
  "\n"
},
{ "__asm_lfence",
  "#line 1 \"<builtin-library>-__asm_lfence\"\n"
  "\n"
  "inline void __asm_lfence(void)\n"
  "{\n"
  "  __CPROVER_fence(\"WWfence\", \"RRfence\", \"RWfence\", \"WRfence\");\n"
  "}\n"
  "\n"
},
{ 0, 0 }
};
